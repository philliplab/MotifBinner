<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>

<title>Investigation of various approach to constructing a consensus string</title>

<script type="text/javascript">
window.onload = function() {
  var imgs = document.getElementsByTagName('img'), i, img;
  for (i = 0; i < imgs.length; i++) {
    img = imgs[i];
    // center an image if it is the only element of its parent
    if (img.parentElement.childElementCount === 1)
      img.parentElement.style.textAlign = 'center';
  }
};
</script>

<!-- Styles for R syntax highlighter -->
<style type="text/css">
   pre .operator,
   pre .paren {
     color: rgb(104, 118, 135)
   }

   pre .literal {
     color: #990073
   }

   pre .number {
     color: #099;
   }

   pre .comment {
     color: #998;
     font-style: italic
   }

   pre .keyword {
     color: #900;
     font-weight: bold
   }

   pre .identifier {
     color: rgb(0, 0, 0);
   }

   pre .string {
     color: #d14;
   }
</style>

<!-- R syntax highlighter -->
<script type="text/javascript">
var hljs=new function(){function m(p){return p.replace(/&/gm,"&amp;").replace(/</gm,"&lt;")}function f(r,q,p){return RegExp(q,"m"+(r.cI?"i":"")+(p?"g":""))}function b(r){for(var p=0;p<r.childNodes.length;p++){var q=r.childNodes[p];if(q.nodeName=="CODE"){return q}if(!(q.nodeType==3&&q.nodeValue.match(/\s+/))){break}}}function h(t,s){var p="";for(var r=0;r<t.childNodes.length;r++){if(t.childNodes[r].nodeType==3){var q=t.childNodes[r].nodeValue;if(s){q=q.replace(/\n/g,"")}p+=q}else{if(t.childNodes[r].nodeName=="BR"){p+="\n"}else{p+=h(t.childNodes[r])}}}if(/MSIE [678]/.test(navigator.userAgent)){p=p.replace(/\r/g,"\n")}return p}function a(s){var r=s.className.split(/\s+/);r=r.concat(s.parentNode.className.split(/\s+/));for(var q=0;q<r.length;q++){var p=r[q].replace(/^language-/,"");if(e[p]){return p}}}function c(q){var p=[];(function(s,t){for(var r=0;r<s.childNodes.length;r++){if(s.childNodes[r].nodeType==3){t+=s.childNodes[r].nodeValue.length}else{if(s.childNodes[r].nodeName=="BR"){t+=1}else{if(s.childNodes[r].nodeType==1){p.push({event:"start",offset:t,node:s.childNodes[r]});t=arguments.callee(s.childNodes[r],t);p.push({event:"stop",offset:t,node:s.childNodes[r]})}}}}return t})(q,0);return p}function k(y,w,x){var q=0;var z="";var s=[];function u(){if(y.length&&w.length){if(y[0].offset!=w[0].offset){return(y[0].offset<w[0].offset)?y:w}else{return w[0].event=="start"?y:w}}else{return y.length?y:w}}function t(D){var A="<"+D.nodeName.toLowerCase();for(var B=0;B<D.attributes.length;B++){var C=D.attributes[B];A+=" "+C.nodeName.toLowerCase();if(C.value!==undefined&&C.value!==false&&C.value!==null){A+='="'+m(C.value)+'"'}}return A+">"}while(y.length||w.length){var v=u().splice(0,1)[0];z+=m(x.substr(q,v.offset-q));q=v.offset;if(v.event=="start"){z+=t(v.node);s.push(v.node)}else{if(v.event=="stop"){var p,r=s.length;do{r--;p=s[r];z+=("</"+p.nodeName.toLowerCase()+">")}while(p!=v.node);s.splice(r,1);while(r<s.length){z+=t(s[r]);r++}}}}return z+m(x.substr(q))}function j(){function q(x,y,v){if(x.compiled){return}var u;var s=[];if(x.k){x.lR=f(y,x.l||hljs.IR,true);for(var w in x.k){if(!x.k.hasOwnProperty(w)){continue}if(x.k[w] instanceof Object){u=x.k[w]}else{u=x.k;w="keyword"}for(var r in u){if(!u.hasOwnProperty(r)){continue}x.k[r]=[w,u[r]];s.push(r)}}}if(!v){if(x.bWK){x.b="\\b("+s.join("|")+")\\s"}x.bR=f(y,x.b?x.b:"\\B|\\b");if(!x.e&&!x.eW){x.e="\\B|\\b"}if(x.e){x.eR=f(y,x.e)}}if(x.i){x.iR=f(y,x.i)}if(x.r===undefined){x.r=1}if(!x.c){x.c=[]}x.compiled=true;for(var t=0;t<x.c.length;t++){if(x.c[t]=="self"){x.c[t]=x}q(x.c[t],y,false)}if(x.starts){q(x.starts,y,false)}}for(var p in e){if(!e.hasOwnProperty(p)){continue}q(e[p].dM,e[p],true)}}function d(B,C){if(!j.called){j();j.called=true}function q(r,M){for(var L=0;L<M.c.length;L++){if((M.c[L].bR.exec(r)||[null])[0]==r){return M.c[L]}}}function v(L,r){if(D[L].e&&D[L].eR.test(r)){return 1}if(D[L].eW){var M=v(L-1,r);return M?M+1:0}return 0}function w(r,L){return L.i&&L.iR.test(r)}function K(N,O){var M=[];for(var L=0;L<N.c.length;L++){M.push(N.c[L].b)}var r=D.length-1;do{if(D[r].e){M.push(D[r].e)}r--}while(D[r+1].eW);if(N.i){M.push(N.i)}return f(O,M.join("|"),true)}function p(M,L){var N=D[D.length-1];if(!N.t){N.t=K(N,E)}N.t.lastIndex=L;var r=N.t.exec(M);return r?[M.substr(L,r.index-L),r[0],false]:[M.substr(L),"",true]}function z(N,r){var L=E.cI?r[0].toLowerCase():r[0];var M=N.k[L];if(M&&M instanceof Array){return M}return false}function F(L,P){L=m(L);if(!P.k){return L}var r="";var O=0;P.lR.lastIndex=0;var M=P.lR.exec(L);while(M){r+=L.substr(O,M.index-O);var N=z(P,M);if(N){x+=N[1];r+='<span class="'+N[0]+'">'+M[0]+"</span>"}else{r+=M[0]}O=P.lR.lastIndex;M=P.lR.exec(L)}return r+L.substr(O,L.length-O)}function J(L,M){if(M.sL&&e[M.sL]){var r=d(M.sL,L);x+=r.keyword_count;return r.value}else{return F(L,M)}}function I(M,r){var L=M.cN?'<span class="'+M.cN+'">':"";if(M.rB){y+=L;M.buffer=""}else{if(M.eB){y+=m(r)+L;M.buffer=""}else{y+=L;M.buffer=r}}D.push(M);A+=M.r}function G(N,M,Q){var R=D[D.length-1];if(Q){y+=J(R.buffer+N,R);return false}var P=q(M,R);if(P){y+=J(R.buffer+N,R);I(P,M);return P.rB}var L=v(D.length-1,M);if(L){var O=R.cN?"</span>":"";if(R.rE){y+=J(R.buffer+N,R)+O}else{if(R.eE){y+=J(R.buffer+N,R)+O+m(M)}else{y+=J(R.buffer+N+M,R)+O}}while(L>1){O=D[D.length-2].cN?"</span>":"";y+=O;L--;D.length--}var r=D[D.length-1];D.length--;D[D.length-1].buffer="";if(r.starts){I(r.starts,"")}return R.rE}if(w(M,R)){throw"Illegal"}}var E=e[B];var D=[E.dM];var A=0;var x=0;var y="";try{var s,u=0;E.dM.buffer="";do{s=p(C,u);var t=G(s[0],s[1],s[2]);u+=s[0].length;if(!t){u+=s[1].length}}while(!s[2]);if(D.length>1){throw"Illegal"}return{r:A,keyword_count:x,value:y}}catch(H){if(H=="Illegal"){return{r:0,keyword_count:0,value:m(C)}}else{throw H}}}function g(t){var p={keyword_count:0,r:0,value:m(t)};var r=p;for(var q in e){if(!e.hasOwnProperty(q)){continue}var s=d(q,t);s.language=q;if(s.keyword_count+s.r>r.keyword_count+r.r){r=s}if(s.keyword_count+s.r>p.keyword_count+p.r){r=p;p=s}}if(r.language){p.second_best=r}return p}function i(r,q,p){if(q){r=r.replace(/^((<[^>]+>|\t)+)/gm,function(t,w,v,u){return w.replace(/\t/g,q)})}if(p){r=r.replace(/\n/g,"<br>")}return r}function n(t,w,r){var x=h(t,r);var v=a(t);var y,s;if(v){y=d(v,x)}else{return}var q=c(t);if(q.length){s=document.createElement("pre");s.innerHTML=y.value;y.value=k(q,c(s),x)}y.value=i(y.value,w,r);var u=t.className;if(!u.match("(\\s|^)(language-)?"+v+"(\\s|$)")){u=u?(u+" "+v):v}if(/MSIE [678]/.test(navigator.userAgent)&&t.tagName=="CODE"&&t.parentNode.tagName=="PRE"){s=t.parentNode;var p=document.createElement("div");p.innerHTML="<pre><code>"+y.value+"</code></pre>";t=p.firstChild.firstChild;p.firstChild.cN=s.cN;s.parentNode.replaceChild(p.firstChild,s)}else{t.innerHTML=y.value}t.className=u;t.result={language:v,kw:y.keyword_count,re:y.r};if(y.second_best){t.second_best={language:y.second_best.language,kw:y.second_best.keyword_count,re:y.second_best.r}}}function o(){if(o.called){return}o.called=true;var r=document.getElementsByTagName("pre");for(var p=0;p<r.length;p++){var q=b(r[p]);if(q){n(q,hljs.tabReplace)}}}function l(){if(window.addEventListener){window.addEventListener("DOMContentLoaded",o,false);window.addEventListener("load",o,false)}else{if(window.attachEvent){window.attachEvent("onload",o)}else{window.onload=o}}}var e={};this.LANGUAGES=e;this.highlight=d;this.highlightAuto=g;this.fixMarkup=i;this.highlightBlock=n;this.initHighlighting=o;this.initHighlightingOnLoad=l;this.IR="[a-zA-Z][a-zA-Z0-9_]*";this.UIR="[a-zA-Z_][a-zA-Z0-9_]*";this.NR="\\b\\d+(\\.\\d+)?";this.CNR="\\b(0[xX][a-fA-F0-9]+|(\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?)";this.BNR="\\b(0b[01]+)";this.RSR="!|!=|!==|%|%=|&|&&|&=|\\*|\\*=|\\+|\\+=|,|\\.|-|-=|/|/=|:|;|<|<<|<<=|<=|=|==|===|>|>=|>>|>>=|>>>|>>>=|\\?|\\[|\\{|\\(|\\^|\\^=|\\||\\|=|\\|\\||~";this.ER="(?![\\s\\S])";this.BE={b:"\\\\.",r:0};this.ASM={cN:"string",b:"'",e:"'",i:"\\n",c:[this.BE],r:0};this.QSM={cN:"string",b:'"',e:'"',i:"\\n",c:[this.BE],r:0};this.CLCM={cN:"comment",b:"//",e:"$"};this.CBLCLM={cN:"comment",b:"/\\*",e:"\\*/"};this.HCM={cN:"comment",b:"#",e:"$"};this.NM={cN:"number",b:this.NR,r:0};this.CNM={cN:"number",b:this.CNR,r:0};this.BNM={cN:"number",b:this.BNR,r:0};this.inherit=function(r,s){var p={};for(var q in r){p[q]=r[q]}if(s){for(var q in s){p[q]=s[q]}}return p}}();hljs.LANGUAGES.cpp=function(){var a={keyword:{"false":1,"int":1,"float":1,"while":1,"private":1,"char":1,"catch":1,"export":1,virtual:1,operator:2,sizeof:2,dynamic_cast:2,typedef:2,const_cast:2,"const":1,struct:1,"for":1,static_cast:2,union:1,namespace:1,unsigned:1,"long":1,"throw":1,"volatile":2,"static":1,"protected":1,bool:1,template:1,mutable:1,"if":1,"public":1,friend:2,"do":1,"return":1,"goto":1,auto:1,"void":2,"enum":1,"else":1,"break":1,"new":1,extern:1,using:1,"true":1,"class":1,asm:1,"case":1,typeid:1,"short":1,reinterpret_cast:2,"default":1,"double":1,register:1,explicit:1,signed:1,typename:1,"try":1,"this":1,"switch":1,"continue":1,wchar_t:1,inline:1,"delete":1,alignof:1,char16_t:1,char32_t:1,constexpr:1,decltype:1,noexcept:1,nullptr:1,static_assert:1,thread_local:1,restrict:1,_Bool:1,complex:1},built_in:{std:1,string:1,cin:1,cout:1,cerr:1,clog:1,stringstream:1,istringstream:1,ostringstream:1,auto_ptr:1,deque:1,list:1,queue:1,stack:1,vector:1,map:1,set:1,bitset:1,multiset:1,multimap:1,unordered_set:1,unordered_map:1,unordered_multiset:1,unordered_multimap:1,array:1,shared_ptr:1}};return{dM:{k:a,i:"</",c:[hljs.CLCM,hljs.CBLCLM,hljs.QSM,{cN:"string",b:"'\\\\?.",e:"'",i:"."},{cN:"number",b:"\\b(\\d+(\\.\\d*)?|\\.\\d+)(u|U|l|L|ul|UL|f|F)"},hljs.CNM,{cN:"preprocessor",b:"#",e:"$"},{cN:"stl_container",b:"\\b(deque|list|queue|stack|vector|map|set|bitset|multiset|multimap|unordered_map|unordered_set|unordered_multiset|unordered_multimap|array)\\s*<",e:">",k:a,r:10,c:["self"]}]}}}();hljs.LANGUAGES.r={dM:{c:[hljs.HCM,{cN:"number",b:"\\b0[xX][0-9a-fA-F]+[Li]?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+(?:[eE][+\\-]?\\d*)?L\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+\\.(?!\\d)(?:i\\b)?",e:hljs.IMMEDIATE_RE,r:1},{cN:"number",b:"\\b\\d+(?:\\.\\d*)?(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\.\\d+(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"keyword",b:"(?:tryCatch|library|setGeneric|setGroupGeneric)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\.",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\d+(?![\\w.])",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\b(?:function)",e:hljs.IMMEDIATE_RE,r:2},{cN:"keyword",b:"(?:if|in|break|next|repeat|else|for|return|switch|while|try|stop|warning|require|attach|detach|source|setMethod|setClass)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"literal",b:"(?:NA|NA_integer_|NA_real_|NA_character_|NA_complex_)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"literal",b:"(?:NULL|TRUE|FALSE|T|F|Inf|NaN)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"identifier",b:"[a-zA-Z.][a-zA-Z0-9._]*\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"<\\-(?!\\s*\\d)",e:hljs.IMMEDIATE_RE,r:2},{cN:"operator",b:"\\->|<\\-",e:hljs.IMMEDIATE_RE,r:1},{cN:"operator",b:"%%|~",e:hljs.IMMEDIATE_RE},{cN:"operator",b:">=|<=|==|!=|\\|\\||&&|=|\\+|\\-|\\*|/|\\^|>|<|!|&|\\||\\$|:",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"%",e:"%",i:"\\n",r:1},{cN:"identifier",b:"`",e:"`",r:0},{cN:"string",b:'"',e:'"',c:[hljs.BE],r:0},{cN:"string",b:"'",e:"'",c:[hljs.BE],r:0},{cN:"paren",b:"[[({\\])}]",e:hljs.IMMEDIATE_RE,r:0}]}};
hljs.initHighlightingOnLoad();
</script>



<style type="text/css">
body, td {
   font-family: sans-serif;
   background-color: white;
   font-size: 13px;
}

body {
  max-width: 800px;
  margin: auto;
  padding: 1em;
  line-height: 20px;
}

tt, code, pre {
   font-family: 'DejaVu Sans Mono', 'Droid Sans Mono', 'Lucida Console', Consolas, Monaco, monospace;
}

h1 {
   font-size:2.2em;
}

h2 {
   font-size:1.8em;
}

h3 {
   font-size:1.4em;
}

h4 {
   font-size:1.0em;
}

h5 {
   font-size:0.9em;
}

h6 {
   font-size:0.8em;
}

a:visited {
   color: rgb(50%, 0%, 50%);
}

pre, img {
  max-width: 100%;
}
pre {
  overflow-x: auto;
}
pre code {
   display: block; padding: 0.5em;
}

code {
  font-size: 92%;
  border: 1px solid #ccc;
}

code[class] {
  background-color: #F8F8F8;
}

table, td, th {
  border: none;
}

blockquote {
   color:#666666;
   margin:0;
   padding-left: 1em;
   border-left: 0.5em #EEE solid;
}

hr {
   height: 0px;
   border-bottom: none;
   border-top-width: thin;
   border-top-style: dotted;
   border-top-color: #999999;
}

@media print {
   * {
      background: transparent !important;
      color: black !important;
      filter:none !important;
      -ms-filter: none !important;
   }

   body {
      font-size:12pt;
      max-width:100%;
   }

   a, a:visited {
      text-decoration: underline;
   }

   hr {
      visibility: hidden;
      page-break-before: always;
   }

   pre, blockquote {
      padding-right: 1em;
      page-break-inside: avoid;
   }

   tr, img {
      page-break-inside: avoid;
   }

   img {
      max-width: 100% !important;
   }

   @page :left {
      margin: 15mm 20mm 15mm 10mm;
   }

   @page :right {
      margin: 15mm 10mm 15mm 20mm;
   }

   p, h2, h3 {
      orphans: 3; widows: 3;
   }

   h2, h3 {
      page-break-after: avoid;
   }
}
</style>



</head>

<body>
<h1>Investigation of various approach to constructing a consensus string</h1>

<pre><code class="r">Sys.time()
</code></pre>

<pre><code>## [1] &quot;2015-03-09 13:12:40 SAST&quot;
</code></pre>

<h2>Overview</h2>

<p>Three important steps needs to be optimized:</p>

<ul>
<li>mislabel classification</li>
<li>alignment</li>
<li>consensus string construction</li>
</ul>

<p>This document investigates all three steps simultaneously by a simulation
process:</p>

<ul>
<li>Given an input string and a read error profile</li>
<li>Potentatially given a contamination string</li>
<li>Simulate reads from both strings and form a bin</li>
<li>Use mislabel classification to throw out outliers</li>
<li>Align the remaining sequences</li>
<li>Construct a final sequence</li>
<li>Compare the reconstructed sequence to the input sequence with edit distance</li>
</ul>

<p>We need very clear terminology to keep track of the different aspects of the
simulations:</p>

<ul>
<li>All the parameters that goes into the three steps are called a &#39;setup&#39;</li>
<li>A input sequence, number of reads, contamination sequence, number of
contamination reads and the error profile is called a &#39;scenario&#39; or &#39;test
scenario&#39;.</li>
<li>A test scenario, setup and a seed is called a &#39;case&#39; or &#39;test case&#39;.</li>
</ul>

<h2>The setups</h2>

<pre><code class="r">setups &lt;- list()
setups[[&#39;base&#39;]] &lt;- list(classification_technique = &#39;infovar_balance&#39;, 
                         classification_params = list(threshold = 1), 
                         alignment_technique = &#39;muscle&#39;, 
                         alignment_params = list(), 
                         consensus_technique = &#39;Biostrings::consensusString&#39;, 
                         consensus_params = list(ambiguityMap = &#39;N&#39;))

setups[[&#39;base1&#39;]] &lt;- list(classification_technique = &#39;infovar_balance&#39;, 
                         classification_params = list(threshold = 1,
                                          start_threshold = 0.02), 
                         alignment_technique = &#39;muscle&#39;, 
                         alignment_params = list(), 
                         consensus_technique = &#39;Biostrings::consensusString&#39;, 
                         consensus_params = list(ambiguityMap = &#39;N&#39;))


setups[[&#39;most_con&#39;]] &lt;- list(classification_technique = &#39;infovar_balance&#39;, 
                         classification_params = list(threshold = 1,
                                          start_threshold = 0.02), 
                         alignment_technique = &#39;muscle&#39;, 
                         alignment_params = list(), 
                         consensus_technique = &#39;mostConsensusString&#39;, 
                         consensus_params = list())
</code></pre>

<h2>The error profiles</h2>

<h3>Three very basic error profiles</h3>

<pre><code class="r">err_profiles &lt;- list()

x &lt;- list(read_len = 1000,
          A_err_rates = list(&#39;A&#39; = 0.997, &#39;C&#39; = 0.001, &#39;G&#39; = 0.001, &#39;T&#39; = 0.001),
          C_err_rates = list(&#39;C&#39; = 0.997, &#39;A&#39; = 0.001, &#39;G&#39; = 0.001, &#39;T&#39; = 0.001),
          G_err_rates = list(&#39;G&#39; = 0.997, &#39;C&#39; = 0.001, &#39;A&#39; = 0.001, &#39;T&#39; = 0.001),
          T_err_rates = list(&#39;T&#39; = 0.997, &#39;C&#39; = 0.001, &#39;G&#39; = 0.001, &#39;A&#39; = 0.001))
params &lt;- list()
params[[&#39;params&#39;]] &lt;- x
params[[&#39;technique&#39;]] &lt;- &#39;uniform&#39;
err_profiles[[&#39;unif_1_1000&#39;]] &lt;- do.call(gen_error_profile, params)


x &lt;- list(read_len = 1000,
          A_err_rates = list(&#39;A&#39; = 0.97, &#39;C&#39; = 0.01, &#39;G&#39; = 0.01, &#39;T&#39; = 0.01),
          C_err_rates = list(&#39;C&#39; = 0.97, &#39;A&#39; = 0.01, &#39;G&#39; = 0.01, &#39;T&#39; = 0.01),
          G_err_rates = list(&#39;G&#39; = 0.97, &#39;C&#39; = 0.01, &#39;A&#39; = 0.01, &#39;T&#39; = 0.01),
          T_err_rates = list(&#39;T&#39; = 0.97, &#39;C&#39; = 0.01, &#39;G&#39; = 0.01, &#39;A&#39; = 0.01))
params &lt;- list()
params[[&#39;params&#39;]] &lt;- x
params[[&#39;technique&#39;]] &lt;- &#39;uniform&#39;
err_profiles[[&#39;unif_1_100&#39;]] &lt;- do.call(gen_error_profile, params)

x &lt;- list(read_len = 1000,
          A_err_rates = list(&#39;A&#39; = 0.7, &#39;C&#39; = 0.1, &#39;G&#39; = 0.1, &#39;T&#39; = 0.1),
          C_err_rates = list(&#39;C&#39; = 0.7, &#39;A&#39; = 0.1, &#39;G&#39; = 0.1, &#39;T&#39; = 0.1),
          G_err_rates = list(&#39;G&#39; = 0.7, &#39;C&#39; = 0.1, &#39;A&#39; = 0.1, &#39;T&#39; = 0.1),
          T_err_rates = list(&#39;T&#39; = 0.7, &#39;C&#39; = 0.1, &#39;G&#39; = 0.1, &#39;A&#39; = 0.1))
params &lt;- list()
params[[&#39;params&#39;]] &lt;- x
params[[&#39;technique&#39;]] &lt;- &#39;uniform&#39;
err_profiles[[&#39;unif_1_10&#39;]] &lt;- do.call(gen_error_profile, params)
</code></pre>

<h2>The test scenarios</h2>

<pre><code class="r">scenarios &lt;- list()
scenarios[[&#39;unif_read_1&#39;]] &lt;- list(name = &#39;unif_read_1&#39;,
                                   ref_seq = paste(rep(&#39;A&#39;, 500), collapse = &quot;&quot;), 
                                   n_reads = 10, 
                                   error_rates = err_profiles[[&#39;unif_1_1000&#39;]], 
                                   contam_seq = NULL, 
                                   n_contam = 0)
scenarios[[&#39;unif_read_2&#39;]] &lt;- list(name = &#39;unif_read_2&#39;,
                                   ref_seq = paste(rep(&#39;A&#39;, 500), collapse = &quot;&quot;), 
                                   n_reads = 10, 
                                   error_rates = err_profiles[[&#39;unif_1_100&#39;]], 
                                   contam_seq = NULL, 
                                   n_contam = 0)
scenarios[[&#39;unif_read_3&#39;]] &lt;- list(name = &#39;unif_read_3&#39;,
                                   ref_seq = paste(rep(&#39;A&#39;, 500), collapse = &quot;&quot;), 
                                   n_reads = 10, 
                                   error_rates = err_profiles[[&#39;unif_1_10&#39;]], 
                                   contam_seq = NULL, 
                                   n_contam = 0)

scenarios[[&#39;unif_contam_1&#39;]] &lt;- list(name = &#39;unif_contam_1&#39;,
                                     ref_seq = paste(rep(&#39;A&#39;, 500), collapse = &quot;&quot;), 
                                     n_reads = 10, 
                                     error_rates = err_profiles[[&#39;unif_1_100&#39;]], 
                                     contam_seq = paste(c(rep(&#39;A&#39;, 200), rep(&#39;C&#39;, 100), rep(&#39;A&#39;, 200)), collapse = &quot;&quot;), 
                                     n_contam = 1)
scenarios[[&#39;unif_contam_2&#39;]] &lt;- list(name = &#39;unif_contam_2&#39;,
                                     ref_seq = paste(rep(&#39;A&#39;, 500), collapse = &quot;&quot;), 
                                     n_reads = 10, 
                                     error_rates = err_profiles[[&#39;unif_1_100&#39;]], 
                                     contam_seq = paste(c(rep(&#39;A&#39;, 200), rep(&#39;C&#39;, 100), rep(&#39;A&#39;, 200)), collapse = &quot;&quot;), 
                                     n_contam = 5)
scenarios[[&#39;unif_contam_3&#39;]] &lt;- list(name = &#39;unif_contam_3&#39;,
                                     ref_seq = paste(rep(&#39;A&#39;, 500), collapse = &quot;&quot;), 
                                     n_reads = 10, 
                                     error_rates = err_profiles[[&#39;unif_1_100&#39;]], 
                                     contam_seq = paste(c(rep(&#39;A&#39;, 200), rep(&#39;C&#39;, 100), rep(&#39;A&#39;, 200)), collapse = &quot;&quot;), 
                                     n_contam = 9)
</code></pre>

<h2>The test cases</h2>

<pre><code class="r">cases &lt;- list()
seeds &lt;- 1:3

for (setup in names(setups)){
  for (scenario in names(scenarios)){
    for (seed in seeds){
      case_name &lt;- paste(setup, scenario, seed, sep = &#39;-&#39;)
      cases[[case_name]] &lt;- list(scenario = scenarios[[scenario]],
                                 seed = seed,
                                 setup = setups[[setup]])
    }
  }
}
</code></pre>

<h2>The test runner</h2>

<pre><code class="r">list_unique_scenarios &lt;- function(cases){

  unique_scenarios &lt;- list()

  for (tc in names(cases)){
    params &lt;- cases[[tc]]$scenario
    params[[&#39;seed&#39;]] &lt;- cases[[tc]]$seed
    hash &lt;- digest(params)
    unique_scenarios[[hash]] &lt;- params
  }
  return(unique_scenarios)
}

unique_scenarios &lt;- list_unique_scenarios(cases)

cache_file &lt;- &#39;~/projects/MotifBinner/code/MotifBinner/inst/scenario_cache.rdata&#39;

if (file.exists(cache_file)){
  load(cache_file)
} else {
  scenario_cache &lt;- list()
}

x &lt;- foreach (hash = names(unique_scenarios)) %dopar% {
  if (hash %in% names(scenario_cache)){
    result &lt;- list(res = scenario_cache[[hash]], hash = hash)
  } else {
    params &lt;- unique_scenarios[[hash]]
    params$name &lt;- NULL
    res &lt;- do.call( gen_and_contaminate_reads, params)
    result &lt;- list(res = res, hash = hash)
  }
  result
}

for (i in seq_along(x)){
  hash &lt;- x[[i]]$hash
  res &lt;- x[[i]]$res
  scenario_cache[[hash]] &lt;- res
}

save(scenario_cache, file = cache_file)

run_test &lt;- function(scenario, seed, setup){
  params &lt;- scenario
  params[[&#39;seed&#39;]] &lt;- seed

  test_bin &lt;- scenario_cache[[digest(params)]]

  params &lt;- setup
  params$test_bin &lt;- test_bin
  result &lt;- do.call(score_consensus, params)
  return(list(mismatch = result$edit_dist,
              output_len = nchar(result$alignment)))
}
</code></pre>

<h2>Running the test cases.</h2>

<pre><code class="r">results &lt;- data.frame(setup = character(0),
                      scenario = character(0),
                      seed = character(0),
                      mismatch = numeric(0),
                      input_len = numeric(0),
                      output_len = numeric(0),
                      mismatch_rate = numeric(0))

for (tc in names(cases)){
  print(tc)
  split_names &lt;- strsplit(tc, split=&#39;-&#39;)[[1]]
  setup &lt;- split_names[1]
  scenario &lt;- split_names[2]
  seed &lt;- split_names[3]
  test_result &lt;- do.call(run_test, cases[[tc]])
  output_len &lt;- test_result$output_len
  mismatch &lt;- test_result$mismatch
  input_len &lt;- nchar(cases[[tc]][[&#39;scenario&#39;]][[&#39;ref_seq&#39;]])
  results &lt;- rbind(results,
                   data.frame(setup = setup,
                              scenario = scenario,
                              seed = seed,
                              mismatch = mismatch,
                              input_len = input_len,
                              output_len = output_len,
                              mismatch_rate = mismatch / input_len))
}
</code></pre>

<h2>The results</h2>

<pre><code class="r">kable(results)
</code></pre>

<table><thead>
<tr>
<th align="left">setup</th>
<th align="left">scenario</th>
<th align="left">seed</th>
<th align="right">mismatch</th>
<th align="right">input_len</th>
<th align="right">output_len</th>
<th align="right">mismatch_rate</th>
</tr>
</thead><tbody>
<tr>
<td align="left">base</td>
<td align="left">unif_read_1</td>
<td align="left">1</td>
<td align="right">1</td>
<td align="right">500</td>
<td align="right">500</td>
<td align="right">0.002</td>
</tr>
<tr>
<td align="left">base</td>
<td align="left">unif_read_1</td>
<td align="left">2</td>
<td align="right">0</td>
<td align="right">500</td>
<td align="right">0</td>
<td align="right">0.000</td>
</tr>
<tr>
<td align="left">base</td>
<td align="left">unif_read_1</td>
<td align="left">3</td>
<td align="right">0</td>
<td align="right">500</td>
<td align="right">0</td>
<td align="right">0.000</td>
</tr>
<tr>
<td align="left">base</td>
<td align="left">unif_read_2</td>
<td align="left">1</td>
<td align="right">0</td>
<td align="right">500</td>
<td align="right">0</td>
<td align="right">0.000</td>
</tr>
<tr>
<td align="left">base</td>
<td align="left">unif_read_2</td>
<td align="left">2</td>
<td align="right">0</td>
<td align="right">500</td>
<td align="right">0</td>
<td align="right">0.000</td>
</tr>
<tr>
<td align="left">base</td>
<td align="left">unif_read_2</td>
<td align="left">3</td>
<td align="right">0</td>
<td align="right">500</td>
<td align="right">0</td>
<td align="right">0.000</td>
</tr>
<tr>
<td align="left">base</td>
<td align="left">unif_read_3</td>
<td align="left">1</td>
<td align="right">171</td>
<td align="right">500</td>
<td align="right">507</td>
<td align="right">0.342</td>
</tr>
<tr>
<td align="left">base</td>
<td align="left">unif_read_3</td>
<td align="left">2</td>
<td align="right">173</td>
<td align="right">500</td>
<td align="right">500</td>
<td align="right">0.346</td>
</tr>
<tr>
<td align="left">base</td>
<td align="left">unif_read_3</td>
<td align="left">3</td>
<td align="right">160</td>
<td align="right">500</td>
<td align="right">519</td>
<td align="right">0.320</td>
</tr>
<tr>
<td align="left">base</td>
<td align="left">unif_contam_1</td>
<td align="left">1</td>
<td align="right">0</td>
<td align="right">500</td>
<td align="right">0</td>
<td align="right">0.000</td>
</tr>
<tr>
<td align="left">base</td>
<td align="left">unif_contam_1</td>
<td align="left">2</td>
<td align="right">0</td>
<td align="right">500</td>
<td align="right">0</td>
<td align="right">0.000</td>
</tr>
<tr>
<td align="left">base</td>
<td align="left">unif_contam_1</td>
<td align="left">3</td>
<td align="right">0</td>
<td align="right">500</td>
<td align="right">0</td>
<td align="right">0.000</td>
</tr>
<tr>
<td align="left">base</td>
<td align="left">unif_contam_2</td>
<td align="left">1</td>
<td align="right">197</td>
<td align="right">500</td>
<td align="right">597</td>
<td align="right">0.394</td>
</tr>
<tr>
<td align="left">base</td>
<td align="left">unif_contam_2</td>
<td align="left">2</td>
<td align="right">199</td>
<td align="right">500</td>
<td align="right">599</td>
<td align="right">0.398</td>
</tr>
<tr>
<td align="left">base</td>
<td align="left">unif_contam_2</td>
<td align="left">3</td>
<td align="right">200</td>
<td align="right">500</td>
<td align="right">600</td>
<td align="right">0.400</td>
</tr>
<tr>
<td align="left">base</td>
<td align="left">unif_contam_3</td>
<td align="left">1</td>
<td align="right">200</td>
<td align="right">500</td>
<td align="right">600</td>
<td align="right">0.400</td>
</tr>
<tr>
<td align="left">base</td>
<td align="left">unif_contam_3</td>
<td align="left">2</td>
<td align="right">200</td>
<td align="right">500</td>
<td align="right">600</td>
<td align="right">0.400</td>
</tr>
<tr>
<td align="left">base</td>
<td align="left">unif_contam_3</td>
<td align="left">3</td>
<td align="right">200</td>
<td align="right">500</td>
<td align="right">600</td>
<td align="right">0.400</td>
</tr>
<tr>
<td align="left">base1</td>
<td align="left">unif_read_1</td>
<td align="left">1</td>
<td align="right">0</td>
<td align="right">500</td>
<td align="right">0</td>
<td align="right">0.000</td>
</tr>
<tr>
<td align="left">base1</td>
<td align="left">unif_read_1</td>
<td align="left">2</td>
<td align="right">0</td>
<td align="right">500</td>
<td align="right">0</td>
<td align="right">0.000</td>
</tr>
<tr>
<td align="left">base1</td>
<td align="left">unif_read_1</td>
<td align="left">3</td>
<td align="right">0</td>
<td align="right">500</td>
<td align="right">0</td>
<td align="right">0.000</td>
</tr>
<tr>
<td align="left">base1</td>
<td align="left">unif_read_2</td>
<td align="left">1</td>
<td align="right">0</td>
<td align="right">500</td>
<td align="right">0</td>
<td align="right">0.000</td>
</tr>
<tr>
<td align="left">base1</td>
<td align="left">unif_read_2</td>
<td align="left">2</td>
<td align="right">0</td>
<td align="right">500</td>
<td align="right">0</td>
<td align="right">0.000</td>
</tr>
<tr>
<td align="left">base1</td>
<td align="left">unif_read_2</td>
<td align="left">3</td>
<td align="right">0</td>
<td align="right">500</td>
<td align="right">0</td>
<td align="right">0.000</td>
</tr>
<tr>
<td align="left">base1</td>
<td align="left">unif_read_3</td>
<td align="left">1</td>
<td align="right">171</td>
<td align="right">500</td>
<td align="right">507</td>
<td align="right">0.342</td>
</tr>
<tr>
<td align="left">base1</td>
<td align="left">unif_read_3</td>
<td align="left">2</td>
<td align="right">173</td>
<td align="right">500</td>
<td align="right">500</td>
<td align="right">0.346</td>
</tr>
<tr>
<td align="left">base1</td>
<td align="left">unif_read_3</td>
<td align="left">3</td>
<td align="right">160</td>
<td align="right">500</td>
<td align="right">519</td>
<td align="right">0.320</td>
</tr>
<tr>
<td align="left">base1</td>
<td align="left">unif_contam_1</td>
<td align="left">1</td>
<td align="right">0</td>
<td align="right">500</td>
<td align="right">0</td>
<td align="right">0.000</td>
</tr>
<tr>
<td align="left">base1</td>
<td align="left">unif_contam_1</td>
<td align="left">2</td>
<td align="right">0</td>
<td align="right">500</td>
<td align="right">0</td>
<td align="right">0.000</td>
</tr>
<tr>
<td align="left">base1</td>
<td align="left">unif_contam_1</td>
<td align="left">3</td>
<td align="right">0</td>
<td align="right">500</td>
<td align="right">0</td>
<td align="right">0.000</td>
</tr>
<tr>
<td align="left">base1</td>
<td align="left">unif_contam_2</td>
<td align="left">1</td>
<td align="right">197</td>
<td align="right">500</td>
<td align="right">597</td>
<td align="right">0.394</td>
</tr>
<tr>
<td align="left">base1</td>
<td align="left">unif_contam_2</td>
<td align="left">2</td>
<td align="right">199</td>
<td align="right">500</td>
<td align="right">599</td>
<td align="right">0.398</td>
</tr>
<tr>
<td align="left">base1</td>
<td align="left">unif_contam_2</td>
<td align="left">3</td>
<td align="right">200</td>
<td align="right">500</td>
<td align="right">600</td>
<td align="right">0.400</td>
</tr>
<tr>
<td align="left">base1</td>
<td align="left">unif_contam_3</td>
<td align="left">1</td>
<td align="right">200</td>
<td align="right">500</td>
<td align="right">600</td>
<td align="right">0.400</td>
</tr>
<tr>
<td align="left">base1</td>
<td align="left">unif_contam_3</td>
<td align="left">2</td>
<td align="right">200</td>
<td align="right">500</td>
<td align="right">600</td>
<td align="right">0.400</td>
</tr>
<tr>
<td align="left">base1</td>
<td align="left">unif_contam_3</td>
<td align="left">3</td>
<td align="right">200</td>
<td align="right">500</td>
<td align="right">600</td>
<td align="right">0.400</td>
</tr>
<tr>
<td align="left">most_con</td>
<td align="left">unif_read_1</td>
<td align="left">1</td>
<td align="right">0</td>
<td align="right">500</td>
<td align="right">0</td>
<td align="right">0.000</td>
</tr>
<tr>
<td align="left">most_con</td>
<td align="left">unif_read_1</td>
<td align="left">2</td>
<td align="right">0</td>
<td align="right">500</td>
<td align="right">0</td>
<td align="right">0.000</td>
</tr>
<tr>
<td align="left">most_con</td>
<td align="left">unif_read_1</td>
<td align="left">3</td>
<td align="right">0</td>
<td align="right">500</td>
<td align="right">0</td>
<td align="right">0.000</td>
</tr>
<tr>
<td align="left">most_con</td>
<td align="left">unif_read_2</td>
<td align="left">1</td>
<td align="right">0</td>
<td align="right">500</td>
<td align="right">0</td>
<td align="right">0.000</td>
</tr>
<tr>
<td align="left">most_con</td>
<td align="left">unif_read_2</td>
<td align="left">2</td>
<td align="right">0</td>
<td align="right">500</td>
<td align="right">0</td>
<td align="right">0.000</td>
</tr>
<tr>
<td align="left">most_con</td>
<td align="left">unif_read_2</td>
<td align="left">3</td>
<td align="right">0</td>
<td align="right">500</td>
<td align="right">0</td>
<td align="right">0.000</td>
</tr>
<tr>
<td align="left">most_con</td>
<td align="left">unif_read_3</td>
<td align="left">1</td>
<td align="right">79</td>
<td align="right">500</td>
<td align="right">500</td>
<td align="right">0.158</td>
</tr>
<tr>
<td align="left">most_con</td>
<td align="left">unif_read_3</td>
<td align="left">2</td>
<td align="right">87</td>
<td align="right">500</td>
<td align="right">500</td>
<td align="right">0.174</td>
</tr>
<tr>
<td align="left">most_con</td>
<td align="left">unif_read_3</td>
<td align="left">3</td>
<td align="right">76</td>
<td align="right">500</td>
<td align="right">500</td>
<td align="right">0.152</td>
</tr>
<tr>
<td align="left">most_con</td>
<td align="left">unif_contam_1</td>
<td align="left">1</td>
<td align="right">0</td>
<td align="right">500</td>
<td align="right">0</td>
<td align="right">0.000</td>
</tr>
<tr>
<td align="left">most_con</td>
<td align="left">unif_contam_1</td>
<td align="left">2</td>
<td align="right">0</td>
<td align="right">500</td>
<td align="right">0</td>
<td align="right">0.000</td>
</tr>
<tr>
<td align="left">most_con</td>
<td align="left">unif_contam_1</td>
<td align="left">3</td>
<td align="right">0</td>
<td align="right">500</td>
<td align="right">0</td>
<td align="right">0.000</td>
</tr>
<tr>
<td align="left">most_con</td>
<td align="left">unif_contam_2</td>
<td align="left">1</td>
<td align="right">0</td>
<td align="right">500</td>
<td align="right">0</td>
<td align="right">0.000</td>
</tr>
<tr>
<td align="left">most_con</td>
<td align="left">unif_contam_2</td>
<td align="left">2</td>
<td align="right">0</td>
<td align="right">500</td>
<td align="right">0</td>
<td align="right">0.000</td>
</tr>
<tr>
<td align="left">most_con</td>
<td align="left">unif_contam_2</td>
<td align="left">3</td>
<td align="right">0</td>
<td align="right">500</td>
<td align="right">0</td>
<td align="right">0.000</td>
</tr>
<tr>
<td align="left">most_con</td>
<td align="left">unif_contam_3</td>
<td align="left">1</td>
<td align="right">27</td>
<td align="right">500</td>
<td align="right">500</td>
<td align="right">0.054</td>
</tr>
<tr>
<td align="left">most_con</td>
<td align="left">unif_contam_3</td>
<td align="left">2</td>
<td align="right">38</td>
<td align="right">500</td>
<td align="right">500</td>
<td align="right">0.076</td>
</tr>
<tr>
<td align="left">most_con</td>
<td align="left">unif_contam_3</td>
<td align="left">3</td>
<td align="right">36</td>
<td align="right">500</td>
<td align="right">500</td>
<td align="right">0.072</td>
</tr>
</tbody></table>

<h2>Fixes resulting from benchmarking</h2>

<h3>ur1_b_1</h3>

<p>A single mismatch was found on this super simple and easy case. The primary
cause is that the infovar_balance classification technique tries to remove
contamination from a bin with no contamination. Set a starting criteria for the
infovar_balance technique so that it will only start if the maximum distance
in the distance matrix is above some threshold.</p>

<pre><code class="r"># Generate test data
test_bin &lt;- do.call(gen_and_contaminate_reads, c(scenarios[[&#39;unif_read_1&#39;]], list(seed=1)))

# See how easy the problem is
consensusString(test_bin$src) == test_bin$true_consensus
</code></pre>

<pre><code>## [1] TRUE
</code></pre>

<pre><code class="r"># See how the basic technique fails

params &lt;- setups[[&#39;base&#39;]]
params$test_bin &lt;- test_bin
result &lt;- do.call(score_consensus, params)
result$edit_dist
</code></pre>

<pre><code>## [1] 1
</code></pre>

<pre><code class="r"># Fix it with the starting threshold:
params[[&#39;classification_params&#39;]] &lt;- list(threshold = 1,
                                          start_threshold = 0.02)
result &lt;- do.call(score_consensus, params)
result$edit_dist
</code></pre>

<pre><code>## [1] 0
</code></pre>

<h2>Utility Functions</h2>

<pre><code class="r">list_to_env &lt;- function(x){
  for (i in names(x)){
    p &lt;- list(x = i, value = x[[i]], envir = .GlobalEnv)
    do.call(assign, p)
  }
}
</code></pre>

<h2>How does the consensusString Function in Biostrings actually work?</h2>

<p>When and how does ambigueity characters get added to the data. Should I write
my own version of the function to deal with it?</p>

<h3>It behaves as expected for matching sequences</h3>

<pre><code class="r">consensusString(DNAStringSet(c(&#39;AAA&#39;, &#39;AAA&#39;)))
</code></pre>

<pre><code>## [1] &quot;AAA&quot;
</code></pre>

<pre><code class="r">consensusString(DNAStringSet(c(&#39;ACGT&#39;, &#39;ACGT&#39;)))
</code></pre>

<pre><code>## [1] &quot;ACGT&quot;
</code></pre>

<h3>For mismatches - a very strict threshold must be met</h3>

<pre><code class="r">consensusString(DNAStringSet(c(&#39;AAC&#39;, &#39;AAA&#39;)))
</code></pre>

<pre><code>## [1] &quot;AAM&quot;
</code></pre>

<pre><code class="r">consensusString(DNAStringSet(c(&#39;AAC&#39;, &#39;AAA&#39;, &#39;AAA&#39;)))
</code></pre>

<pre><code>## [1] &quot;AAM&quot;
</code></pre>

<pre><code class="r">consensusString(DNAStringSet(c(&#39;AAC&#39;, &#39;AAA&#39;, &#39;AAA&#39;, &#39;AAA&#39;)))
</code></pre>

<pre><code>## [1] &quot;AAM&quot;
</code></pre>

<pre><code class="r">consensusString(DNAStringSet(c(&#39;AAC&#39;, &#39;AAA&#39;, &#39;AAA&#39;, &#39;AAA&#39;, &#39;AAA&#39;)))
</code></pre>

<pre><code>## [1] &quot;AAA&quot;
</code></pre>

<pre><code class="r">consensusString(DNAStringSet(c(&#39;AAC&#39;, &#39;AAT&#39;, &#39;AAA&#39;, &#39;AAA&#39;, &#39;AAA&#39;, &#39;AAA&#39;)))
</code></pre>

<pre><code>## [1] &quot;AAA&quot;
</code></pre>

<h3>Can this threshold be lowered?</h3>

<pre><code class="r">consensusString(DNAStringSet(c(&#39;AAC&#39;, &#39;AAA&#39;)), threshold = 0.5)
</code></pre>

<pre><code>## Error in .local(x, ...): &#39;threshold&#39; must be a numeric in (0, 1/sum(nchar(ambiguityMap) == 1)]
</code></pre>

<p>No because they are using some strange restrictions.  Specifically the
threshold is that no other character may occur more than 25% of the time. This
is stricter than the current behaviour. Is this a problem or can the stricter
behaviour be used?</p>

<p>If you want to use the 50% criteria again, then I would have to either write my
own consensusString generator or modify theirs - it might take a bit of time.</p>

<p>I think it would probably be better to reduce that restriction because what
this means is that any bin with 2, 3 or 4 sequences that are not identical will
have degeneracy (unless the sequences with mismatches were removed by the
outlier detector)</p>

<p>Added easyConsensusString to handle this. Which later morphed into
mostConsensusString.</p>

<h2>Benchmarks for contamination</h2>

<p>The purpose here is to create a benchmark that will test the effectiveness of
outlier removal and explore what happens in some edge cases. Some of these
benchmarks should make it into the unit tests eventually.</p>

<p>Testing the interaction between contamination and read errors is not so
important, so only use 1 in 100 read error rate.</p>

<p>What is important to explore is what happens when the level of contamination
changes. so try with 10%, 25% and 45% and 50% contamination and check what
happens. Note that the mislabel detector will really struggle on 45% and 50% in
its current form so this is probably where I will hit the crossroads and have
to implement the mislabel detector that is based on absolute thresholds.</p>

<p>The sequence to use for the contamination should not be too rediculous
otherwise it will make the aligner go nuts if the mislabel detector fails to
remove it. The current test string is 500 A&#39;s So for contamination try using
200 As followed by 100 Cs then another 200 As. This is 1 mutation / read error
for every 5 bases which is very obviously a contaminant. Also try a lower level
of errors. Try 245 As, 10 Cs, 245 As. This is still a read error / mutation
rate of 1 in 50 which is higher than the simulated read error rate, so it
should be detectable.</p>

<p>The problem is still that the aligner chooses to insert gaps with these thus
greatly inflating the mismatch scores. Well, maybe this is not that bad since
the benchmark shows that the mislabel detector failed and that is kind the only
thing that matters.</p>

</body>

</html>
