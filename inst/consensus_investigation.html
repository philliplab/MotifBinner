<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>

<title>Investigation of various approach to constructing a consensus string</title>

<script type="text/javascript">
window.onload = function() {
  var imgs = document.getElementsByTagName('img'), i, img;
  for (i = 0; i < imgs.length; i++) {
    img = imgs[i];
    // center an image if it is the only element of its parent
    if (img.parentElement.childElementCount === 1)
      img.parentElement.style.textAlign = 'center';
  }
};
</script>

<!-- Styles for R syntax highlighter -->
<style type="text/css">
   pre .operator,
   pre .paren {
     color: rgb(104, 118, 135)
   }

   pre .literal {
     color: #990073
   }

   pre .number {
     color: #099;
   }

   pre .comment {
     color: #998;
     font-style: italic
   }

   pre .keyword {
     color: #900;
     font-weight: bold
   }

   pre .identifier {
     color: rgb(0, 0, 0);
   }

   pre .string {
     color: #d14;
   }
</style>

<!-- R syntax highlighter -->
<script type="text/javascript">
var hljs=new function(){function m(p){return p.replace(/&/gm,"&amp;").replace(/</gm,"&lt;")}function f(r,q,p){return RegExp(q,"m"+(r.cI?"i":"")+(p?"g":""))}function b(r){for(var p=0;p<r.childNodes.length;p++){var q=r.childNodes[p];if(q.nodeName=="CODE"){return q}if(!(q.nodeType==3&&q.nodeValue.match(/\s+/))){break}}}function h(t,s){var p="";for(var r=0;r<t.childNodes.length;r++){if(t.childNodes[r].nodeType==3){var q=t.childNodes[r].nodeValue;if(s){q=q.replace(/\n/g,"")}p+=q}else{if(t.childNodes[r].nodeName=="BR"){p+="\n"}else{p+=h(t.childNodes[r])}}}if(/MSIE [678]/.test(navigator.userAgent)){p=p.replace(/\r/g,"\n")}return p}function a(s){var r=s.className.split(/\s+/);r=r.concat(s.parentNode.className.split(/\s+/));for(var q=0;q<r.length;q++){var p=r[q].replace(/^language-/,"");if(e[p]){return p}}}function c(q){var p=[];(function(s,t){for(var r=0;r<s.childNodes.length;r++){if(s.childNodes[r].nodeType==3){t+=s.childNodes[r].nodeValue.length}else{if(s.childNodes[r].nodeName=="BR"){t+=1}else{if(s.childNodes[r].nodeType==1){p.push({event:"start",offset:t,node:s.childNodes[r]});t=arguments.callee(s.childNodes[r],t);p.push({event:"stop",offset:t,node:s.childNodes[r]})}}}}return t})(q,0);return p}function k(y,w,x){var q=0;var z="";var s=[];function u(){if(y.length&&w.length){if(y[0].offset!=w[0].offset){return(y[0].offset<w[0].offset)?y:w}else{return w[0].event=="start"?y:w}}else{return y.length?y:w}}function t(D){var A="<"+D.nodeName.toLowerCase();for(var B=0;B<D.attributes.length;B++){var C=D.attributes[B];A+=" "+C.nodeName.toLowerCase();if(C.value!==undefined&&C.value!==false&&C.value!==null){A+='="'+m(C.value)+'"'}}return A+">"}while(y.length||w.length){var v=u().splice(0,1)[0];z+=m(x.substr(q,v.offset-q));q=v.offset;if(v.event=="start"){z+=t(v.node);s.push(v.node)}else{if(v.event=="stop"){var p,r=s.length;do{r--;p=s[r];z+=("</"+p.nodeName.toLowerCase()+">")}while(p!=v.node);s.splice(r,1);while(r<s.length){z+=t(s[r]);r++}}}}return z+m(x.substr(q))}function j(){function q(x,y,v){if(x.compiled){return}var u;var s=[];if(x.k){x.lR=f(y,x.l||hljs.IR,true);for(var w in x.k){if(!x.k.hasOwnProperty(w)){continue}if(x.k[w] instanceof Object){u=x.k[w]}else{u=x.k;w="keyword"}for(var r in u){if(!u.hasOwnProperty(r)){continue}x.k[r]=[w,u[r]];s.push(r)}}}if(!v){if(x.bWK){x.b="\\b("+s.join("|")+")\\s"}x.bR=f(y,x.b?x.b:"\\B|\\b");if(!x.e&&!x.eW){x.e="\\B|\\b"}if(x.e){x.eR=f(y,x.e)}}if(x.i){x.iR=f(y,x.i)}if(x.r===undefined){x.r=1}if(!x.c){x.c=[]}x.compiled=true;for(var t=0;t<x.c.length;t++){if(x.c[t]=="self"){x.c[t]=x}q(x.c[t],y,false)}if(x.starts){q(x.starts,y,false)}}for(var p in e){if(!e.hasOwnProperty(p)){continue}q(e[p].dM,e[p],true)}}function d(B,C){if(!j.called){j();j.called=true}function q(r,M){for(var L=0;L<M.c.length;L++){if((M.c[L].bR.exec(r)||[null])[0]==r){return M.c[L]}}}function v(L,r){if(D[L].e&&D[L].eR.test(r)){return 1}if(D[L].eW){var M=v(L-1,r);return M?M+1:0}return 0}function w(r,L){return L.i&&L.iR.test(r)}function K(N,O){var M=[];for(var L=0;L<N.c.length;L++){M.push(N.c[L].b)}var r=D.length-1;do{if(D[r].e){M.push(D[r].e)}r--}while(D[r+1].eW);if(N.i){M.push(N.i)}return f(O,M.join("|"),true)}function p(M,L){var N=D[D.length-1];if(!N.t){N.t=K(N,E)}N.t.lastIndex=L;var r=N.t.exec(M);return r?[M.substr(L,r.index-L),r[0],false]:[M.substr(L),"",true]}function z(N,r){var L=E.cI?r[0].toLowerCase():r[0];var M=N.k[L];if(M&&M instanceof Array){return M}return false}function F(L,P){L=m(L);if(!P.k){return L}var r="";var O=0;P.lR.lastIndex=0;var M=P.lR.exec(L);while(M){r+=L.substr(O,M.index-O);var N=z(P,M);if(N){x+=N[1];r+='<span class="'+N[0]+'">'+M[0]+"</span>"}else{r+=M[0]}O=P.lR.lastIndex;M=P.lR.exec(L)}return r+L.substr(O,L.length-O)}function J(L,M){if(M.sL&&e[M.sL]){var r=d(M.sL,L);x+=r.keyword_count;return r.value}else{return F(L,M)}}function I(M,r){var L=M.cN?'<span class="'+M.cN+'">':"";if(M.rB){y+=L;M.buffer=""}else{if(M.eB){y+=m(r)+L;M.buffer=""}else{y+=L;M.buffer=r}}D.push(M);A+=M.r}function G(N,M,Q){var R=D[D.length-1];if(Q){y+=J(R.buffer+N,R);return false}var P=q(M,R);if(P){y+=J(R.buffer+N,R);I(P,M);return P.rB}var L=v(D.length-1,M);if(L){var O=R.cN?"</span>":"";if(R.rE){y+=J(R.buffer+N,R)+O}else{if(R.eE){y+=J(R.buffer+N,R)+O+m(M)}else{y+=J(R.buffer+N+M,R)+O}}while(L>1){O=D[D.length-2].cN?"</span>":"";y+=O;L--;D.length--}var r=D[D.length-1];D.length--;D[D.length-1].buffer="";if(r.starts){I(r.starts,"")}return R.rE}if(w(M,R)){throw"Illegal"}}var E=e[B];var D=[E.dM];var A=0;var x=0;var y="";try{var s,u=0;E.dM.buffer="";do{s=p(C,u);var t=G(s[0],s[1],s[2]);u+=s[0].length;if(!t){u+=s[1].length}}while(!s[2]);if(D.length>1){throw"Illegal"}return{r:A,keyword_count:x,value:y}}catch(H){if(H=="Illegal"){return{r:0,keyword_count:0,value:m(C)}}else{throw H}}}function g(t){var p={keyword_count:0,r:0,value:m(t)};var r=p;for(var q in e){if(!e.hasOwnProperty(q)){continue}var s=d(q,t);s.language=q;if(s.keyword_count+s.r>r.keyword_count+r.r){r=s}if(s.keyword_count+s.r>p.keyword_count+p.r){r=p;p=s}}if(r.language){p.second_best=r}return p}function i(r,q,p){if(q){r=r.replace(/^((<[^>]+>|\t)+)/gm,function(t,w,v,u){return w.replace(/\t/g,q)})}if(p){r=r.replace(/\n/g,"<br>")}return r}function n(t,w,r){var x=h(t,r);var v=a(t);var y,s;if(v){y=d(v,x)}else{return}var q=c(t);if(q.length){s=document.createElement("pre");s.innerHTML=y.value;y.value=k(q,c(s),x)}y.value=i(y.value,w,r);var u=t.className;if(!u.match("(\\s|^)(language-)?"+v+"(\\s|$)")){u=u?(u+" "+v):v}if(/MSIE [678]/.test(navigator.userAgent)&&t.tagName=="CODE"&&t.parentNode.tagName=="PRE"){s=t.parentNode;var p=document.createElement("div");p.innerHTML="<pre><code>"+y.value+"</code></pre>";t=p.firstChild.firstChild;p.firstChild.cN=s.cN;s.parentNode.replaceChild(p.firstChild,s)}else{t.innerHTML=y.value}t.className=u;t.result={language:v,kw:y.keyword_count,re:y.r};if(y.second_best){t.second_best={language:y.second_best.language,kw:y.second_best.keyword_count,re:y.second_best.r}}}function o(){if(o.called){return}o.called=true;var r=document.getElementsByTagName("pre");for(var p=0;p<r.length;p++){var q=b(r[p]);if(q){n(q,hljs.tabReplace)}}}function l(){if(window.addEventListener){window.addEventListener("DOMContentLoaded",o,false);window.addEventListener("load",o,false)}else{if(window.attachEvent){window.attachEvent("onload",o)}else{window.onload=o}}}var e={};this.LANGUAGES=e;this.highlight=d;this.highlightAuto=g;this.fixMarkup=i;this.highlightBlock=n;this.initHighlighting=o;this.initHighlightingOnLoad=l;this.IR="[a-zA-Z][a-zA-Z0-9_]*";this.UIR="[a-zA-Z_][a-zA-Z0-9_]*";this.NR="\\b\\d+(\\.\\d+)?";this.CNR="\\b(0[xX][a-fA-F0-9]+|(\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?)";this.BNR="\\b(0b[01]+)";this.RSR="!|!=|!==|%|%=|&|&&|&=|\\*|\\*=|\\+|\\+=|,|\\.|-|-=|/|/=|:|;|<|<<|<<=|<=|=|==|===|>|>=|>>|>>=|>>>|>>>=|\\?|\\[|\\{|\\(|\\^|\\^=|\\||\\|=|\\|\\||~";this.ER="(?![\\s\\S])";this.BE={b:"\\\\.",r:0};this.ASM={cN:"string",b:"'",e:"'",i:"\\n",c:[this.BE],r:0};this.QSM={cN:"string",b:'"',e:'"',i:"\\n",c:[this.BE],r:0};this.CLCM={cN:"comment",b:"//",e:"$"};this.CBLCLM={cN:"comment",b:"/\\*",e:"\\*/"};this.HCM={cN:"comment",b:"#",e:"$"};this.NM={cN:"number",b:this.NR,r:0};this.CNM={cN:"number",b:this.CNR,r:0};this.BNM={cN:"number",b:this.BNR,r:0};this.inherit=function(r,s){var p={};for(var q in r){p[q]=r[q]}if(s){for(var q in s){p[q]=s[q]}}return p}}();hljs.LANGUAGES.cpp=function(){var a={keyword:{"false":1,"int":1,"float":1,"while":1,"private":1,"char":1,"catch":1,"export":1,virtual:1,operator:2,sizeof:2,dynamic_cast:2,typedef:2,const_cast:2,"const":1,struct:1,"for":1,static_cast:2,union:1,namespace:1,unsigned:1,"long":1,"throw":1,"volatile":2,"static":1,"protected":1,bool:1,template:1,mutable:1,"if":1,"public":1,friend:2,"do":1,"return":1,"goto":1,auto:1,"void":2,"enum":1,"else":1,"break":1,"new":1,extern:1,using:1,"true":1,"class":1,asm:1,"case":1,typeid:1,"short":1,reinterpret_cast:2,"default":1,"double":1,register:1,explicit:1,signed:1,typename:1,"try":1,"this":1,"switch":1,"continue":1,wchar_t:1,inline:1,"delete":1,alignof:1,char16_t:1,char32_t:1,constexpr:1,decltype:1,noexcept:1,nullptr:1,static_assert:1,thread_local:1,restrict:1,_Bool:1,complex:1},built_in:{std:1,string:1,cin:1,cout:1,cerr:1,clog:1,stringstream:1,istringstream:1,ostringstream:1,auto_ptr:1,deque:1,list:1,queue:1,stack:1,vector:1,map:1,set:1,bitset:1,multiset:1,multimap:1,unordered_set:1,unordered_map:1,unordered_multiset:1,unordered_multimap:1,array:1,shared_ptr:1}};return{dM:{k:a,i:"</",c:[hljs.CLCM,hljs.CBLCLM,hljs.QSM,{cN:"string",b:"'\\\\?.",e:"'",i:"."},{cN:"number",b:"\\b(\\d+(\\.\\d*)?|\\.\\d+)(u|U|l|L|ul|UL|f|F)"},hljs.CNM,{cN:"preprocessor",b:"#",e:"$"},{cN:"stl_container",b:"\\b(deque|list|queue|stack|vector|map|set|bitset|multiset|multimap|unordered_map|unordered_set|unordered_multiset|unordered_multimap|array)\\s*<",e:">",k:a,r:10,c:["self"]}]}}}();hljs.LANGUAGES.r={dM:{c:[hljs.HCM,{cN:"number",b:"\\b0[xX][0-9a-fA-F]+[Li]?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+(?:[eE][+\\-]?\\d*)?L\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+\\.(?!\\d)(?:i\\b)?",e:hljs.IMMEDIATE_RE,r:1},{cN:"number",b:"\\b\\d+(?:\\.\\d*)?(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\.\\d+(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"keyword",b:"(?:tryCatch|library|setGeneric|setGroupGeneric)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\.",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\d+(?![\\w.])",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\b(?:function)",e:hljs.IMMEDIATE_RE,r:2},{cN:"keyword",b:"(?:if|in|break|next|repeat|else|for|return|switch|while|try|stop|warning|require|attach|detach|source|setMethod|setClass)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"literal",b:"(?:NA|NA_integer_|NA_real_|NA_character_|NA_complex_)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"literal",b:"(?:NULL|TRUE|FALSE|T|F|Inf|NaN)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"identifier",b:"[a-zA-Z.][a-zA-Z0-9._]*\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"<\\-(?!\\s*\\d)",e:hljs.IMMEDIATE_RE,r:2},{cN:"operator",b:"\\->|<\\-",e:hljs.IMMEDIATE_RE,r:1},{cN:"operator",b:"%%|~",e:hljs.IMMEDIATE_RE},{cN:"operator",b:">=|<=|==|!=|\\|\\||&&|=|\\+|\\-|\\*|/|\\^|>|<|!|&|\\||\\$|:",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"%",e:"%",i:"\\n",r:1},{cN:"identifier",b:"`",e:"`",r:0},{cN:"string",b:'"',e:'"',c:[hljs.BE],r:0},{cN:"string",b:"'",e:"'",c:[hljs.BE],r:0},{cN:"paren",b:"[[({\\])}]",e:hljs.IMMEDIATE_RE,r:0}]}};
hljs.initHighlightingOnLoad();
</script>



<style type="text/css">
body, td {
   font-family: sans-serif;
   background-color: white;
   font-size: 13px;
}

body {
  max-width: 800px;
  margin: auto;
  padding: 1em;
  line-height: 20px;
}

tt, code, pre {
   font-family: 'DejaVu Sans Mono', 'Droid Sans Mono', 'Lucida Console', Consolas, Monaco, monospace;
}

h1 {
   font-size:2.2em;
}

h2 {
   font-size:1.8em;
}

h3 {
   font-size:1.4em;
}

h4 {
   font-size:1.0em;
}

h5 {
   font-size:0.9em;
}

h6 {
   font-size:0.8em;
}

a:visited {
   color: rgb(50%, 0%, 50%);
}

pre, img {
  max-width: 100%;
}
pre {
  overflow-x: auto;
}
pre code {
   display: block; padding: 0.5em;
}

code {
  font-size: 92%;
  border: 1px solid #ccc;
}

code[class] {
  background-color: #F8F8F8;
}

table, td, th {
  border: none;
}

blockquote {
   color:#666666;
   margin:0;
   padding-left: 1em;
   border-left: 0.5em #EEE solid;
}

hr {
   height: 0px;
   border-bottom: none;
   border-top-width: thin;
   border-top-style: dotted;
   border-top-color: #999999;
}

@media print {
   * {
      background: transparent !important;
      color: black !important;
      filter:none !important;
      -ms-filter: none !important;
   }

   body {
      font-size:12pt;
      max-width:100%;
   }

   a, a:visited {
      text-decoration: underline;
   }

   hr {
      visibility: hidden;
      page-break-before: always;
   }

   pre, blockquote {
      padding-right: 1em;
      page-break-inside: avoid;
   }

   tr, img {
      page-break-inside: avoid;
   }

   img {
      max-width: 100% !important;
   }

   @page :left {
      margin: 15mm 20mm 15mm 10mm;
   }

   @page :right {
      margin: 15mm 10mm 15mm 20mm;
   }

   p, h2, h3 {
      orphans: 3; widows: 3;
   }

   h2, h3 {
      page-break-after: avoid;
   }
}
</style>



</head>

<body>
<h1>Investigation of various approach to constructing a consensus string</h1>

<pre><code class="r">Sys.time()
</code></pre>

<pre><code>## [1] &quot;2015-03-11 13:27:40 SAST&quot;
</code></pre>

<h2>Overview</h2>

<p>Three important steps needs to be optimized:</p>

<ul>
<li>mislabel classification</li>
<li>alignment</li>
<li>consensus string construction</li>
</ul>

<p>This document investigates all three steps simultaneously by a simulation
process:</p>

<ul>
<li>Given an input string and a read error profile</li>
<li>Potentatially given a contamination string</li>
<li>Simulate reads from both strings and form a bin</li>
<li>Use mislabel classification to throw out outliers</li>
<li>Align the remaining sequences</li>
<li>Construct a final sequence</li>
<li>Compare the reconstructed sequence to the input sequence with edit distance</li>
</ul>

<p>We need very clear terminology to keep track of the different aspects of the
simulations:</p>

<ul>
<li>All the parameters that goes into the three steps are called a &#39;setup&#39;</li>
<li>A input sequence, number of reads, contamination sequence, number of
contamination reads and the error profile is called a &#39;scenario&#39; or &#39;test
scenario&#39;.</li>
<li>A test scenario, setup and a seed is called a &#39;case&#39; or &#39;test case&#39;.</li>
</ul>

<h2>The setups</h2>

<pre><code class="r">setups &lt;- list()
setups[[&#39;base&#39;]] &lt;- list(classification_technique = &#39;infovar_balance&#39;, 
                         classification_params = list(threshold = 1), 
                         alignment_technique = &#39;muscle&#39;, 
                         alignment_params = list(), 
                         consensus_technique = &#39;Biostrings::consensusString&#39;, 
                         consensus_params = list(ambiguityMap = &#39;N&#39;))

setups[[&#39;base1&#39;]] &lt;- list(classification_technique = &#39;infovar_balance&#39;, 
                         classification_params = list(threshold = 1,
                                          start_threshold = 0.02), 
                         alignment_technique = &#39;muscle&#39;, 
                         alignment_params = list(), 
                         consensus_technique = &#39;Biostrings::consensusString&#39;, 
                         consensus_params = list(ambiguityMap = &#39;N&#39;))


setups[[&#39;most_con&#39;]] &lt;- list(classification_technique = &#39;infovar_balance&#39;, 
                         classification_params = list(threshold = 1,
                                          start_threshold = 0.02), 
                         alignment_technique = &#39;muscle&#39;, 
                         alignment_params = list(), 
                         consensus_technique = &#39;mostConsensusString&#39;, 
                         consensus_params = list())
</code></pre>

<h2>The error profiles</h2>

<h3>Three very basic error profiles</h3>

<pre><code class="r">err_profiles &lt;- list()

x &lt;- list(read_len = 1000,
          A_err_rates = list(&#39;A&#39; = 0.997, &#39;C&#39; = 0.001, &#39;G&#39; = 0.001, &#39;T&#39; = 0.001),
          C_err_rates = list(&#39;C&#39; = 0.997, &#39;A&#39; = 0.001, &#39;G&#39; = 0.001, &#39;T&#39; = 0.001),
          G_err_rates = list(&#39;G&#39; = 0.997, &#39;C&#39; = 0.001, &#39;A&#39; = 0.001, &#39;T&#39; = 0.001),
          T_err_rates = list(&#39;T&#39; = 0.997, &#39;C&#39; = 0.001, &#39;G&#39; = 0.001, &#39;A&#39; = 0.001))
params &lt;- list()
params[[&#39;params&#39;]] &lt;- x
params[[&#39;technique&#39;]] &lt;- &#39;uniform&#39;
err_profiles[[&#39;unif_1_1000&#39;]] &lt;- do.call(gen_error_profile, params)


x &lt;- list(read_len = 1000,
          A_err_rates = list(&#39;A&#39; = 0.97, &#39;C&#39; = 0.01, &#39;G&#39; = 0.01, &#39;T&#39; = 0.01),
          C_err_rates = list(&#39;C&#39; = 0.97, &#39;A&#39; = 0.01, &#39;G&#39; = 0.01, &#39;T&#39; = 0.01),
          G_err_rates = list(&#39;G&#39; = 0.97, &#39;C&#39; = 0.01, &#39;A&#39; = 0.01, &#39;T&#39; = 0.01),
          T_err_rates = list(&#39;T&#39; = 0.97, &#39;C&#39; = 0.01, &#39;G&#39; = 0.01, &#39;A&#39; = 0.01))
params &lt;- list()
params[[&#39;params&#39;]] &lt;- x
params[[&#39;technique&#39;]] &lt;- &#39;uniform&#39;
err_profiles[[&#39;unif_1_100&#39;]] &lt;- do.call(gen_error_profile, params)

x &lt;- list(read_len = 1000,
          A_err_rates = list(&#39;A&#39; = 0.7, &#39;C&#39; = 0.1, &#39;G&#39; = 0.1, &#39;T&#39; = 0.1),
          C_err_rates = list(&#39;C&#39; = 0.7, &#39;A&#39; = 0.1, &#39;G&#39; = 0.1, &#39;T&#39; = 0.1),
          G_err_rates = list(&#39;G&#39; = 0.7, &#39;C&#39; = 0.1, &#39;A&#39; = 0.1, &#39;T&#39; = 0.1),
          T_err_rates = list(&#39;T&#39; = 0.7, &#39;C&#39; = 0.1, &#39;G&#39; = 0.1, &#39;A&#39; = 0.1))
params &lt;- list()
params[[&#39;params&#39;]] &lt;- x
params[[&#39;technique&#39;]] &lt;- &#39;uniform&#39;
err_profiles[[&#39;unif_1_10&#39;]] &lt;- do.call(gen_error_profile, params)
</code></pre>

<h2>The test scenarios</h2>

<pre><code class="r">scenarios &lt;- list()
scenarios[[&#39;unif_read_1&#39;]] &lt;- list(name = &#39;unif_read_1&#39;,
                                   ref_seq = paste(rep(&#39;A&#39;, 500), collapse = &quot;&quot;), 
                                   n_reads = 10, 
                                   error_rates = err_profiles[[&#39;unif_1_1000&#39;]], 
                                   contam_seq = NULL, 
                                   n_contam = 0)
scenarios[[&#39;unif_read_2&#39;]] &lt;- list(name = &#39;unif_read_2&#39;,
                                   ref_seq = paste(rep(&#39;A&#39;, 500), collapse = &quot;&quot;), 
                                   n_reads = 10, 
                                   error_rates = err_profiles[[&#39;unif_1_100&#39;]], 
                                   contam_seq = NULL, 
                                   n_contam = 0)
scenarios[[&#39;unif_read_3&#39;]] &lt;- list(name = &#39;unif_read_3&#39;,
                                   ref_seq = paste(rep(&#39;A&#39;, 500), collapse = &quot;&quot;), 
                                   n_reads = 10, 
                                   error_rates = err_profiles[[&#39;unif_1_10&#39;]], 
                                   contam_seq = NULL, 
                                   n_contam = 0)

scenarios[[&#39;unif_contam_1&#39;]] &lt;- list(name = &#39;unif_contam_1&#39;,
                                     ref_seq = paste(rep(&#39;A&#39;, 500), collapse = &quot;&quot;), 
                                     n_reads = 10, 
                                     error_rates = err_profiles[[&#39;unif_1_100&#39;]], 
                                     contam_seq = paste(c(rep(&#39;A&#39;, 200), rep(&#39;C&#39;, 100), rep(&#39;A&#39;, 200)), collapse = &quot;&quot;), 
                                     n_contam = 1)
scenarios[[&#39;unif_contam_2&#39;]] &lt;- list(name = &#39;unif_contam_2&#39;,
                                     ref_seq = paste(rep(&#39;A&#39;, 500), collapse = &quot;&quot;), 
                                     n_reads = 10, 
                                     error_rates = err_profiles[[&#39;unif_1_100&#39;]], 
                                     contam_seq = paste(c(rep(&#39;A&#39;, 200), rep(&#39;C&#39;, 100), rep(&#39;A&#39;, 200)), collapse = &quot;&quot;), 
                                     n_contam = 5)
scenarios[[&#39;unif_contam_3&#39;]] &lt;- list(name = &#39;unif_contam_3&#39;,
                                     ref_seq = paste(rep(&#39;A&#39;, 500), collapse = &quot;&quot;), 
                                     n_reads = 10, 
                                     error_rates = err_profiles[[&#39;unif_1_100&#39;]], 
                                     contam_seq = paste(c(rep(&#39;A&#39;, 200), rep(&#39;C&#39;, 100), rep(&#39;A&#39;, 200)), collapse = &quot;&quot;), 
                                     n_contam = 9)
</code></pre>

<h2>The test cases</h2>

<pre><code class="r">cases &lt;- list()
seeds &lt;- 1:3

# Note this code is gonna become complex and is going to interact with the case
# specification is weird ways - so leave it here
for (setup in names(setups)){
  for (scenario in names(scenarios)){
    for (seed in seeds){
      case_name &lt;- paste(setup, scenario, seed, sep = &#39;-&#39;)
      cases[[case_name]] &lt;- list(scenario = scenarios[[scenario]],
                                 seed = seed,
                                 setup = setups[[setup]])
    }
  }
}
</code></pre>

<h2>The test runner</h2>

<pre><code class="r">unique_scenarios &lt;- list_unique_scenarios(cases)

cache_file &lt;- &#39;~/projects/MotifBinner/code/MotifBinner/inst/scenario_cache.rdata&#39;

scenario_cache &lt;- load_or_initialize_cache(cache_file)

scenario_cache &lt;- create_scenario_data(unique_scenarios, scenario_cache)

save(scenario_cache, file = cache_file)
</code></pre>

<h2>Running the test cases.</h2>

<pre><code class="r">results &lt;- run_all_tests(cases, scenario_cache)
</code></pre>

<h2>The results</h2>

<pre><code class="r">kable(results)
</code></pre>

<table><thead>
<tr>
<th align="left">setup</th>
<th align="left">scenario</th>
<th align="left">seed</th>
<th align="right">mismatch</th>
<th align="right">input_len</th>
<th align="right">output_len</th>
<th align="right">mismatch_rate</th>
</tr>
</thead><tbody>
<tr>
<td align="left">base</td>
<td align="left">unif_read_1</td>
<td align="left">1</td>
<td align="right">1</td>
<td align="right">500</td>
<td align="right">500</td>
<td align="right">0.002</td>
</tr>
<tr>
<td align="left">base</td>
<td align="left">unif_read_1</td>
<td align="left">2</td>
<td align="right">0</td>
<td align="right">500</td>
<td align="right">0</td>
<td align="right">0.000</td>
</tr>
<tr>
<td align="left">base</td>
<td align="left">unif_read_1</td>
<td align="left">3</td>
<td align="right">0</td>
<td align="right">500</td>
<td align="right">0</td>
<td align="right">0.000</td>
</tr>
<tr>
<td align="left">base</td>
<td align="left">unif_read_2</td>
<td align="left">1</td>
<td align="right">0</td>
<td align="right">500</td>
<td align="right">0</td>
<td align="right">0.000</td>
</tr>
<tr>
<td align="left">base</td>
<td align="left">unif_read_2</td>
<td align="left">2</td>
<td align="right">0</td>
<td align="right">500</td>
<td align="right">0</td>
<td align="right">0.000</td>
</tr>
<tr>
<td align="left">base</td>
<td align="left">unif_read_2</td>
<td align="left">3</td>
<td align="right">0</td>
<td align="right">500</td>
<td align="right">0</td>
<td align="right">0.000</td>
</tr>
<tr>
<td align="left">base</td>
<td align="left">unif_read_3</td>
<td align="left">1</td>
<td align="right">171</td>
<td align="right">500</td>
<td align="right">507</td>
<td align="right">0.342</td>
</tr>
<tr>
<td align="left">base</td>
<td align="left">unif_read_3</td>
<td align="left">2</td>
<td align="right">173</td>
<td align="right">500</td>
<td align="right">500</td>
<td align="right">0.346</td>
</tr>
<tr>
<td align="left">base</td>
<td align="left">unif_read_3</td>
<td align="left">3</td>
<td align="right">160</td>
<td align="right">500</td>
<td align="right">519</td>
<td align="right">0.320</td>
</tr>
<tr>
<td align="left">base</td>
<td align="left">unif_contam_1</td>
<td align="left">1</td>
<td align="right">0</td>
<td align="right">500</td>
<td align="right">0</td>
<td align="right">0.000</td>
</tr>
<tr>
<td align="left">base</td>
<td align="left">unif_contam_1</td>
<td align="left">2</td>
<td align="right">0</td>
<td align="right">500</td>
<td align="right">0</td>
<td align="right">0.000</td>
</tr>
<tr>
<td align="left">base</td>
<td align="left">unif_contam_1</td>
<td align="left">3</td>
<td align="right">0</td>
<td align="right">500</td>
<td align="right">0</td>
<td align="right">0.000</td>
</tr>
<tr>
<td align="left">base</td>
<td align="left">unif_contam_2</td>
<td align="left">1</td>
<td align="right">197</td>
<td align="right">500</td>
<td align="right">597</td>
<td align="right">0.394</td>
</tr>
<tr>
<td align="left">base</td>
<td align="left">unif_contam_2</td>
<td align="left">2</td>
<td align="right">199</td>
<td align="right">500</td>
<td align="right">599</td>
<td align="right">0.398</td>
</tr>
<tr>
<td align="left">base</td>
<td align="left">unif_contam_2</td>
<td align="left">3</td>
<td align="right">200</td>
<td align="right">500</td>
<td align="right">600</td>
<td align="right">0.400</td>
</tr>
<tr>
<td align="left">base</td>
<td align="left">unif_contam_3</td>
<td align="left">1</td>
<td align="right">200</td>
<td align="right">500</td>
<td align="right">600</td>
<td align="right">0.400</td>
</tr>
<tr>
<td align="left">base</td>
<td align="left">unif_contam_3</td>
<td align="left">2</td>
<td align="right">200</td>
<td align="right">500</td>
<td align="right">600</td>
<td align="right">0.400</td>
</tr>
<tr>
<td align="left">base</td>
<td align="left">unif_contam_3</td>
<td align="left">3</td>
<td align="right">200</td>
<td align="right">500</td>
<td align="right">600</td>
<td align="right">0.400</td>
</tr>
<tr>
<td align="left">base1</td>
<td align="left">unif_read_1</td>
<td align="left">1</td>
<td align="right">0</td>
<td align="right">500</td>
<td align="right">0</td>
<td align="right">0.000</td>
</tr>
<tr>
<td align="left">base1</td>
<td align="left">unif_read_1</td>
<td align="left">2</td>
<td align="right">0</td>
<td align="right">500</td>
<td align="right">0</td>
<td align="right">0.000</td>
</tr>
<tr>
<td align="left">base1</td>
<td align="left">unif_read_1</td>
<td align="left">3</td>
<td align="right">0</td>
<td align="right">500</td>
<td align="right">0</td>
<td align="right">0.000</td>
</tr>
<tr>
<td align="left">base1</td>
<td align="left">unif_read_2</td>
<td align="left">1</td>
<td align="right">0</td>
<td align="right">500</td>
<td align="right">0</td>
<td align="right">0.000</td>
</tr>
<tr>
<td align="left">base1</td>
<td align="left">unif_read_2</td>
<td align="left">2</td>
<td align="right">0</td>
<td align="right">500</td>
<td align="right">0</td>
<td align="right">0.000</td>
</tr>
<tr>
<td align="left">base1</td>
<td align="left">unif_read_2</td>
<td align="left">3</td>
<td align="right">0</td>
<td align="right">500</td>
<td align="right">0</td>
<td align="right">0.000</td>
</tr>
<tr>
<td align="left">base1</td>
<td align="left">unif_read_3</td>
<td align="left">1</td>
<td align="right">171</td>
<td align="right">500</td>
<td align="right">507</td>
<td align="right">0.342</td>
</tr>
<tr>
<td align="left">base1</td>
<td align="left">unif_read_3</td>
<td align="left">2</td>
<td align="right">173</td>
<td align="right">500</td>
<td align="right">500</td>
<td align="right">0.346</td>
</tr>
<tr>
<td align="left">base1</td>
<td align="left">unif_read_3</td>
<td align="left">3</td>
<td align="right">160</td>
<td align="right">500</td>
<td align="right">519</td>
<td align="right">0.320</td>
</tr>
<tr>
<td align="left">base1</td>
<td align="left">unif_contam_1</td>
<td align="left">1</td>
<td align="right">0</td>
<td align="right">500</td>
<td align="right">0</td>
<td align="right">0.000</td>
</tr>
<tr>
<td align="left">base1</td>
<td align="left">unif_contam_1</td>
<td align="left">2</td>
<td align="right">0</td>
<td align="right">500</td>
<td align="right">0</td>
<td align="right">0.000</td>
</tr>
<tr>
<td align="left">base1</td>
<td align="left">unif_contam_1</td>
<td align="left">3</td>
<td align="right">0</td>
<td align="right">500</td>
<td align="right">0</td>
<td align="right">0.000</td>
</tr>
<tr>
<td align="left">base1</td>
<td align="left">unif_contam_2</td>
<td align="left">1</td>
<td align="right">197</td>
<td align="right">500</td>
<td align="right">597</td>
<td align="right">0.394</td>
</tr>
<tr>
<td align="left">base1</td>
<td align="left">unif_contam_2</td>
<td align="left">2</td>
<td align="right">199</td>
<td align="right">500</td>
<td align="right">599</td>
<td align="right">0.398</td>
</tr>
<tr>
<td align="left">base1</td>
<td align="left">unif_contam_2</td>
<td align="left">3</td>
<td align="right">200</td>
<td align="right">500</td>
<td align="right">600</td>
<td align="right">0.400</td>
</tr>
<tr>
<td align="left">base1</td>
<td align="left">unif_contam_3</td>
<td align="left">1</td>
<td align="right">200</td>
<td align="right">500</td>
<td align="right">600</td>
<td align="right">0.400</td>
</tr>
<tr>
<td align="left">base1</td>
<td align="left">unif_contam_3</td>
<td align="left">2</td>
<td align="right">200</td>
<td align="right">500</td>
<td align="right">600</td>
<td align="right">0.400</td>
</tr>
<tr>
<td align="left">base1</td>
<td align="left">unif_contam_3</td>
<td align="left">3</td>
<td align="right">200</td>
<td align="right">500</td>
<td align="right">600</td>
<td align="right">0.400</td>
</tr>
<tr>
<td align="left">most_con</td>
<td align="left">unif_read_1</td>
<td align="left">1</td>
<td align="right">0</td>
<td align="right">500</td>
<td align="right">0</td>
<td align="right">0.000</td>
</tr>
<tr>
<td align="left">most_con</td>
<td align="left">unif_read_1</td>
<td align="left">2</td>
<td align="right">0</td>
<td align="right">500</td>
<td align="right">0</td>
<td align="right">0.000</td>
</tr>
<tr>
<td align="left">most_con</td>
<td align="left">unif_read_1</td>
<td align="left">3</td>
<td align="right">0</td>
<td align="right">500</td>
<td align="right">0</td>
<td align="right">0.000</td>
</tr>
<tr>
<td align="left">most_con</td>
<td align="left">unif_read_2</td>
<td align="left">1</td>
<td align="right">0</td>
<td align="right">500</td>
<td align="right">0</td>
<td align="right">0.000</td>
</tr>
<tr>
<td align="left">most_con</td>
<td align="left">unif_read_2</td>
<td align="left">2</td>
<td align="right">0</td>
<td align="right">500</td>
<td align="right">0</td>
<td align="right">0.000</td>
</tr>
<tr>
<td align="left">most_con</td>
<td align="left">unif_read_2</td>
<td align="left">3</td>
<td align="right">0</td>
<td align="right">500</td>
<td align="right">0</td>
<td align="right">0.000</td>
</tr>
<tr>
<td align="left">most_con</td>
<td align="left">unif_read_3</td>
<td align="left">1</td>
<td align="right">79</td>
<td align="right">500</td>
<td align="right">500</td>
<td align="right">0.158</td>
</tr>
<tr>
<td align="left">most_con</td>
<td align="left">unif_read_3</td>
<td align="left">2</td>
<td align="right">87</td>
<td align="right">500</td>
<td align="right">500</td>
<td align="right">0.174</td>
</tr>
<tr>
<td align="left">most_con</td>
<td align="left">unif_read_3</td>
<td align="left">3</td>
<td align="right">76</td>
<td align="right">500</td>
<td align="right">500</td>
<td align="right">0.152</td>
</tr>
<tr>
<td align="left">most_con</td>
<td align="left">unif_contam_1</td>
<td align="left">1</td>
<td align="right">0</td>
<td align="right">500</td>
<td align="right">0</td>
<td align="right">0.000</td>
</tr>
<tr>
<td align="left">most_con</td>
<td align="left">unif_contam_1</td>
<td align="left">2</td>
<td align="right">0</td>
<td align="right">500</td>
<td align="right">0</td>
<td align="right">0.000</td>
</tr>
<tr>
<td align="left">most_con</td>
<td align="left">unif_contam_1</td>
<td align="left">3</td>
<td align="right">0</td>
<td align="right">500</td>
<td align="right">0</td>
<td align="right">0.000</td>
</tr>
<tr>
<td align="left">most_con</td>
<td align="left">unif_contam_2</td>
<td align="left">1</td>
<td align="right">0</td>
<td align="right">500</td>
<td align="right">0</td>
<td align="right">0.000</td>
</tr>
<tr>
<td align="left">most_con</td>
<td align="left">unif_contam_2</td>
<td align="left">2</td>
<td align="right">0</td>
<td align="right">500</td>
<td align="right">0</td>
<td align="right">0.000</td>
</tr>
<tr>
<td align="left">most_con</td>
<td align="left">unif_contam_2</td>
<td align="left">3</td>
<td align="right">0</td>
<td align="right">500</td>
<td align="right">0</td>
<td align="right">0.000</td>
</tr>
<tr>
<td align="left">most_con</td>
<td align="left">unif_contam_3</td>
<td align="left">1</td>
<td align="right">27</td>
<td align="right">500</td>
<td align="right">500</td>
<td align="right">0.054</td>
</tr>
<tr>
<td align="left">most_con</td>
<td align="left">unif_contam_3</td>
<td align="left">2</td>
<td align="right">38</td>
<td align="right">500</td>
<td align="right">500</td>
<td align="right">0.076</td>
</tr>
<tr>
<td align="left">most_con</td>
<td align="left">unif_contam_3</td>
<td align="left">3</td>
<td align="right">36</td>
<td align="right">500</td>
<td align="right">500</td>
<td align="right">0.072</td>
</tr>
</tbody></table>

<h2>Fixes resulting from benchmarking</h2>

<h3>ur1_b_1</h3>

<p>A single mismatch was found on this super simple and easy case. The primary
cause is that the infovar_balance classification technique tries to remove
contamination from a bin with no contamination. Set a starting criteria for the
infovar_balance technique so that it will only start if the maximum distance
in the distance matrix is above some threshold.</p>

<pre><code class="r"># Generate test data
test_bin &lt;- do.call(gen_and_contaminate_reads, c(scenarios[[&#39;unif_read_1&#39;]], list(seed=1)))

# See how easy the problem is
consensusString(test_bin$src) == test_bin$true_consensus
</code></pre>

<pre><code>## [1] TRUE
</code></pre>

<pre><code class="r"># See how the basic technique fails

params &lt;- setups[[&#39;base&#39;]]
params$test_bin &lt;- test_bin
result &lt;- do.call(score_consensus, params)
result$edit_dist
</code></pre>

<pre><code>## [1] 1
</code></pre>

<pre><code class="r"># Fix it with the starting threshold:
params[[&#39;classification_params&#39;]] &lt;- list(threshold = 1,
                                          start_threshold = 0.02)
result &lt;- do.call(score_consensus, params)
result$edit_dist
</code></pre>

<pre><code>## [1] 0
</code></pre>

<h2>Utility Functions</h2>

<pre><code class="r">list_to_env &lt;- function(x){
  for (i in names(x)){
    p &lt;- list(x = i, value = x[[i]], envir = .GlobalEnv)
    do.call(assign, p)
  }
}
</code></pre>

<h2>How does the consensusString Function in Biostrings actually work?</h2>

<p>When and how does ambigueity characters get added to the data. Should I write
my own version of the function to deal with it?</p>

<h3>It behaves as expected for matching sequences</h3>

<pre><code class="r">consensusString(DNAStringSet(c(&#39;AAA&#39;, &#39;AAA&#39;)))
</code></pre>

<pre><code>## [1] &quot;AAA&quot;
</code></pre>

<pre><code class="r">consensusString(DNAStringSet(c(&#39;ACGT&#39;, &#39;ACGT&#39;)))
</code></pre>

<pre><code>## [1] &quot;ACGT&quot;
</code></pre>

<h3>For mismatches - a very strict threshold must be met</h3>

<pre><code class="r">consensusString(DNAStringSet(c(&#39;AAC&#39;, &#39;AAA&#39;)))
</code></pre>

<pre><code>## [1] &quot;AAM&quot;
</code></pre>

<pre><code class="r">consensusString(DNAStringSet(c(&#39;AAC&#39;, &#39;AAA&#39;, &#39;AAA&#39;)))
</code></pre>

<pre><code>## [1] &quot;AAM&quot;
</code></pre>

<pre><code class="r">consensusString(DNAStringSet(c(&#39;AAC&#39;, &#39;AAA&#39;, &#39;AAA&#39;, &#39;AAA&#39;)))
</code></pre>

<pre><code>## [1] &quot;AAM&quot;
</code></pre>

<pre><code class="r">consensusString(DNAStringSet(c(&#39;AAC&#39;, &#39;AAA&#39;, &#39;AAA&#39;, &#39;AAA&#39;, &#39;AAA&#39;)))
</code></pre>

<pre><code>## [1] &quot;AAA&quot;
</code></pre>

<pre><code class="r">consensusString(DNAStringSet(c(&#39;AAC&#39;, &#39;AAT&#39;, &#39;AAA&#39;, &#39;AAA&#39;, &#39;AAA&#39;, &#39;AAA&#39;)))
</code></pre>

<pre><code>## [1] &quot;AAA&quot;
</code></pre>

<h3>Can this threshold be lowered?</h3>

<pre><code class="r">consensusString(DNAStringSet(c(&#39;AAC&#39;, &#39;AAA&#39;)), threshold = 0.5)
</code></pre>

<pre><code>## Error in .local(x, ...): &#39;threshold&#39; must be a numeric in (0, 1/sum(nchar(ambiguityMap) == 1)]
</code></pre>

<p>No because they are using some strange restrictions.  Specifically the
threshold is that no other character may occur more than 25% of the time. This
is stricter than the current behaviour. Is this a problem or can the stricter
behaviour be used?</p>

<p>If you want to use the 50% criteria again, then I would have to either write my
own consensusString generator or modify theirs - it might take a bit of time.</p>

<p>I think it would probably be better to reduce that restriction because what
this means is that any bin with 2, 3 or 4 sequences that are not identical will
have degeneracy (unless the sequences with mismatches were removed by the
outlier detector)</p>

<p>Added easyConsensusString to handle this. Which later morphed into
mostConsensusString.</p>

<h2>Benchmarks for contamination</h2>

<p>The purpose here is to create a benchmark that will test the effectiveness of
outlier removal and explore what happens in some edge cases. Some of these
benchmarks should make it into the unit tests eventually.</p>

<p>Testing the interaction between contamination and read errors is not so
important, so only use 1 in 100 read error rate.</p>

<p>What is important to explore is what happens when the level of contamination
changes. so try with 10%, 25% and 45% and 50% contamination and check what
happens. Note that the mislabel detector will really struggle on 45% and 50% in
its current form so this is probably where I will hit the crossroads and have
to implement the mislabel detector that is based on absolute thresholds.</p>

<p>The sequence to use for the contamination should not be too rediculous
otherwise it will make the aligner go nuts if the mislabel detector fails to
remove it. The current test string is 500 A&#39;s So for contamination try using
200 As followed by 100 Cs then another 200 As. This is 1 mutation / read error
for every 5 bases which is very obviously a contaminant. Also try a lower level
of errors. Try 245 As, 10 Cs, 245 As. This is still a read error / mutation
rate of 1 in 50 which is higher than the simulated read error rate, so it
should be detectable.</p>

<p>The problem is still that the aligner chooses to insert gaps with these thus
greatly inflating the mismatch scores. Well, maybe this is not that bad since
the benchmark shows that the mislabel detector failed and that is kind the only
thing that matters.</p>

<h2>Read Error Rate Computations</h2>

<p>Assuming that the read error rate is described as 1 errorneous base for each
100 bases sequenced, how many mismatches can you expect between two reads in a
bin? What kind of a distribution is this? This is a binomial distribution.</p>

<p>So, what is the probability that there will be 0, 1, 2, 3, &hellip; read errors in a
read of length 500 if the read error rate is 1 in 100?</p>

<pre><code class="r">plot(dbinom(0:20, 500, 1/100))
</code></pre>

<p><img src="data:image/png;base64,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" alt="plot of chunk unnamed-chunk-14"/> </p>

<p>How do we use this to decide when a bin contains outliers? If the distance
between reads are such that it is unlikely that the only source of errors is
the read errors. So the question now becomes:</p>

<p>What is the probability that the distance between two reads is 0 given the only
source of discrepancies is the read errors. This is the probability that
neither read contains any errors plus the chance that the two reads has exactly
the same read errors. The chance of exactly the same read errors occurring are
complicating the matter and the chance of that happening is small, so lets
ignore that for now. </p>

<p>Hence the question becomes: &ldquo;What is the chance of there being 0 read errors in
a read of length 1000 when the chance of a read error is 1/100.</p>

<pre><code class="r">plot(dbinom(0:20, 1000, 1/100))
</code></pre>

<p><img src="data:image/png;base64,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" alt="plot of chunk unnamed-chunk-15"/> </p>

<p>Now, how many read errors can be allowed in a bin before we consider it to be
suspicious? If the chance is less than 5% of there being that many read errors,
then we should suspect alternative error sources. So lets assume a bin of size
two. We just have to find the 95th percentile of the distribution and we are
done.</p>

<pre><code class="r">sample_20 &lt;- pbinom(0:20, 1000, 1/100)
plot(x = 0:20, y=sample_20)
abline(h=0.95)
dist_95 &lt;- abs(sample_20-0.95)
closest_95 &lt;- (0:20)[which(dist_95 == min(dist_95))]
abline(v=closest_95)
</code></pre>

<p><img src="data:image/png;base64,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" alt="plot of chunk unnamed-chunk-16"/> </p>

<p>Now, consider the problematic case where there are more than two sequences in
the bins. Now the question becomes, What is the probability that the largest
and second largest order statistic of a random sample from a binomial
distribution is distance x from each other. The distributions of the order
statistics are significantly more complex than the binomial distribution.</p>

<p>How can you prove this point? Consider the cases where the only source of
distance between sequences are the read errors. Now think what will happen as
the bin size approaches infinity? For any given number x, there will exist a
number y so that if the bin size exceeds y, the probability of there being a
read with more than x errors will exceed say 50%. So this demonstrates that
even if the only source of distance between sequences is read errors, there
will be a big bin size at which any absolute threshold is exceeded.</p>

<p>Now the question is how significant is this effect?</p>

<p>First we need to compute some order statistics. See
<a href="http://en.wikipedia.org/wiki/Order_statistic">http://en.wikipedia.org/wiki/Order_statistic</a></p>

<pre><code class="r">p1f &lt;- function(x, n, p){
  pbinom(x, n, p) - dbinom(x, n, p)
}

p2f &lt;- function(x, n, p){
  dbinom(x, n, p)
}

p3f &lt;- function(x, n, p){
  1 - pbinom(x, n, p)
}

ord_F &lt;- function(x, k, o_n, n, p){
  p1 &lt;- p1f(x, n, p)
  p2 &lt;- p2f(x, n, p)
  p3 &lt;- p3f(x, n, p)
  summ &lt;- 0
  for (j in 0:(o_n-k)){
    summ &lt;- summ + choose(o_n, j) * p3^j * (p1+p2)^(o_n-j)
  }
  summ
}
</code></pre>

<p>Lets just start of simple. What happens to the probability that a single read
contains 5 or more read errors given that the sequence is of length 500 and the
read error rate is 1 in 100?</p>

<p>So lets just look at the maximum order statistic and systematically increase
the number of reads in the bin</p>

<pre><code class="r">probs &lt;- rep(0, 50)
for (i in 1:50){
  probs[i] &lt;- ord_F(10, i, i, 500, 1/100)
}
plot(probs)
</code></pre>

<p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAfgAAAH4CAMAAACR9g9NAAAC91BMVEUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACUDOCmAAAA/XRSTlMAAQIDBAUGBwgJCgsMDQ4PEBESExQVFhcYGRobHB0eHyAhIiMkJSYnKCkqKywtLi8wMTIzNDU2Nzg5Ojs8PT4/QEFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaW1xdXl9gYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXp7fH1+f4CBgoOEhYaHiImKi4yNjo+QkZKTlJWWl5iZmpucnZ6foKGio6SlpqeoqaqrrK2ur7CxsrO0tba3uLm6u7y9vr/AwcLDxMXGx8jJysvMzc7P0NHS09TV1tfY2drb3N3e3+Dh4uPk5ebo6uvs7e7v8PHy8/T19vf4+vv8/f7/cjkqsgAAAAlwSFlzAAALEgAACxIB0t1+/AAAGc5JREFUeJzt3XtAFWXCx/HnwDmACIgcRAQk0lQsb4mmggoq2UVTSUzdStOIrCy1dNVyDXK9YZbrZUvFG6GBCqKGwEHuaN5yzX3bXH13t3bV99VWVm1XpeWPd+a48toc4MyceWaemTm/zx8PdAafeegreC5zZggBAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAj8QjwYL0EUJ1P+vk7DfUX0rxZLwTUlWWLt1qCYvO3sF4IqKuug/2D7xXhBusrqaBdUy0yw5+ZZv+QdFq44bmdrL83aEFtZ5nh+13+Jjcz9+ylGIfwr8ucGZSUKTc8MSemzk9NNDvcjvCaJj/8XeGjGz+1xtgtWkhnZlAErfDJNxs/HbrC7kQhnZlBEbTCO/o4R6mZgQKEd1MI76Zkh4++R7gB4TVNdvhDDT9etBNuQHhNk/+rfvP6pm8XhI9KCJG7J6BIfvgRc5u+/WfhTZ/sW1U2U+6ugB6V7txNW8ANe3oqtS+QTKXw9t1MmqHUvkAylcJnPMYNr09Qal8gmUrhHykOJT0q/ZXaF0im1hM4ccUndz2o1K5AOjxz56YQ3k0hvJtSO/zgrC9+2VqpXYJ4KocfXhju9UKBSal9gmgqh8+3csPmbkrtE0RTOXw5/8P+/jCl9gmiqRx+XSIhntVBSu0TRFM5vLU6fWbRdKV2CeKpfa/ec/CYUKX2CBLgcbybQng3xSp8mwmT8SufJUbhe9bMm10xQqldg3OMwhdHEOJXo9SuwTlG4Sv4Iae9UvsGp1iF599WXSX3pAzgOkbhp2yLCl+yTKldg3Os7tWP2p0/BS/SMYTH8W4K4d0U8/AhgUotAFrCOHznstw9nwcotQRoHuPwFdzuR2YqtQRoHtvwIbn8WKnUEqB5bMMHFPBjuVJLgOYx/lWf/zghs5YotQRoHuPwwRuLbel45pYB5g/ngA2Ed1MI76Y0Er5Lnq3sLaVWAk3QRvhWtQ8QU8ZLSi0FHGkjfCz/0rz/QaWWAo60EX5IOje0wnnOVaSN8K1rQgiZjxMgqkgb4cmA0n1lGbhsoYo0Ep77oUd2VWkmPKgL4d2UxsLHVhw+/Cz1pYAjbYWPrLAS7z2x9BcDQtoKn/ICN8Sspr4WcKCt8K9O5IZea6ivBRxoK3znolbEc0si/cWAkLbCk6TKvVV4Ak8NGgtPCM5prw7NhQd1aDW8V6QnrYVAUzQa/p3jeSfwRI6StBl+9AYTsRTiXMcKohG+dXBTr6zJCb+Wv0LdpFddnwCckR3ef/0PDQ23v3rV4fQWcsJ/2JcbXpwmY1nghOzwOWvDF6+OmHQuTbhBTvjHdrci1sM4A6KCZIevCyR+171JJ7pXkx7/5YmKQTL+PDgjO/x3w8lDty1k/F+FG/A4XtNkh3/t4vo/fEKW30gSbkB4TZN/r3542mQP0svqcDuV8B5xYztQmAYc0HocHz5aeAuN8IFVS944hEd1SqAVPvlm46dDV9idLJY/6+qnuR96Wzv5E4GQAs/chcTY7cqTP9Vh/gn7hSPlTwRCNMJ7BNB+5u6e3Ahu2NRD/kQgJDu8T/r5Ow31F9K8hRtohB9i62iZ/AXOeasA2eGzbPFWS1Bs/hbhBir36mN3FC7wozAPCMl/5u7uwy3fK8INeByvabLDn7n7UkrSaeEGhNc02eH7Xf4mNzP37KUY4Qaq4Z/ckT0N/9TTJP9evTkxdX5qotnhdprhJ+/tFJaxlN58oNEjcITKvLih3IvehKCP8PaLVmV1pDch6CN8YST3uOE4/pGnSB/hH66dnVr+FL35QCfhiX/yL/DyLFU6CQ+06Sy8ZwSuXUSHvsJHH8nKPRBMf143pK/wtocIGbqd/rxuSFfhg+zHduASNjToKnzrQ/xYSX1ed6Sr8CRnLPGYg+fsadBXeP91lTWLHF8PAun0FR6oQXg3pc/wXu98keVw5AdIocvwprznvSIODVFsfnegy/DRW7khNF+x+d2BLsMPW8wNJjyRI4cuw1v5t1Yl/Eax+d2BLsOTlKKZH1QFKTe/G9BneNJhzGBcw0YWnYYHuXQevu/04TgE0yX6Dv/pJ5PSbQ7v0wURdB0+bh03TMNVqF2h6/Azx3PDA9sU348R6Tr8mHe54cl0xfdjRLoO71U6PnhILQ64d4Wuw5NW83YtDVF+N0ak7/DgMoOEb9sbZ8qRxhjhVx3MKJ2l3u6MwBDhx60kxLTrUdX2ZwSGCL+mFzeMmaPa/ozAEOHTh3HDS7iSiRSGCN/9cDvyYDUe10lhiPCkf37Jzi7q7c4IjBEeJDNYeN8IBjvVJUOF9/i46rOjcarvVpcMFX7224QE1LZRfb96ZKjwha254b1E1ferR4YKn8+fGWkJfteLYajwz31qId2rfVTfrx4ZKjx582jZF13V360eGSs8iGbQ8G3aM9y5LhgyvP+uPTsqcNGyFhky/MYnCYmqYbZ7XTBk+Ep+2BnObP96YMjw9lMm7MXbqFtiyPBp7xAyooDZ7nXBkOEtabbiTbgGdYsMGR6cM3Z4nwExOAFq0+iEb9PEdSM0EL53bcaaygdYr0KbZIfvXr7XevBWfaXDoS8aCF/dnpBu+1mvQptkh69av+rqcm+fjw8IN7AP33YfP1bgXClNkR3+n+39/+1DSOB14Qb24c2l3GCqYL0MbZId/vsRAxseIyT+nHAD+/Bk/SyTZflC1qvQJtnhX7v9j9cuZW69lizcoIHw3u+Xlc3yZL0KbZJ/r/6hDiR63gLH18I0EB6aR+txfPho4S1aCv/orKkBrNegMbTCJ99s/HRCqd33ZXRmpmDRjqenHH+Q9Sq0xdjP3N3Vjr9q2cNZrJehLTTCewQ0dUJh7YQfaj8hGh7W/Yzs8D7p5+801F9IczixqHbCR/Cv0EbtYb0MbZEdPssWb7UExeZvEW7QTniyKT168BGcKeVnZIevu3t+Qd8rwg0aCm8a/5v0TqwXoTGyw5+5ewaSpNPCDRoKD45kh+93+ZvczNyzlxwuA6fB8O3X23IGsl6ERsi/V29OTJ2fmuh4vIP2wvtV9yNhlT1ZL0Mb3OFx/D1j53LDgNWsl6EN7hT+5ee5IRJP5Ni5U/hHdnPD3FdYL0Mb3Ck8mVv47o5svExr51bhSbsEvFTzH+4V/p6wGLd/u4Vbhs84mGH7JetFMOaO4Uet4IYt/Vkvgy13DL+Kf5bxKTf/kXfH8ItGcsPzqayXwZY7hu9S3pF0rQ5lvQy23DE86XugfG831otgTGT4h7x83kjxkjSzhsOD2PCLbwXP+92pTZJm1kH42N3FK5t4n69bEBf+hz6mP/eO+kHSzNoP378w0vKszU2fwhUXvi6q93emiBuSZtZ++G384VgfPsZ6GWyIC//JHy/MiTwj7Z3m2g9fxJ/uePY41stgQ1x4c/Ik84PzpL0LSfvhP0gmxFTckfUy2BB5r94zOr6TxBMMaD+878F1s4pTWK+CEXHhe5+78tXfj0s7Qln74Ylp4Fi3Pf2luPAnPzATr1WVkmbWQfh7Wj/7vNtdvUpc+Ov8RbqD/iFpZv2E71z7TsrhJNarUJm48LlTuOHlfEkz6yf8vi6EeB93sxPiiQmfnZ3XcGrvVz9tlDSzfsLb30f7STTrZahLTPgX7pE0s37Cl7bihmI/1stQl9hX5zxDpf4q1E/4sQe6dEhfw3oVKhMXvv3uOz/e2SvtOt36CU+Gb9+Z2tS5HYxMXPiCre1I8LZ9kmbWUfhGwe5zcQORD+faEgM/nLsnoriweH8w61WoRFz48yO4YYTDyStbpL/whT0IGZTLehUqERc+uW5b2ra68ZJm1l1430J+LHOTf+xF3qvvNHvFbIlH5+kuvKWEH7Vzdj5liQt/to/0mXUXnmQ9Qchza1mvQiXiwi/aKO1AS57+wrfZevzEOl/Wq1CJuPCVdTcunDtn9Dt3bkVc+Oi7JM2s3/Dtt5TYZrBehNJE3rkzdUnoJvHurm7De5T1Ix6rjP4OK3Hhu3999av/PesmP/Hd+PcPeJWyXobCxIX/crmFmH99RNLMug3f5yNuMBn9YZ3I4+r5JzIdrzfUIt2G96rlvtvJS1kvQ2Hiwme/YSLkpb2SZtZteDKoaltBtg/rVShMXPjNd35f8FXDoZwcCTH1G56QMOMflSEu/KRG4mfWc/i7Ij87aYtnvQiluOX748Xxr+lN2hUa9a11CN+sZ/hT3/bcwHoZCkH4Zr0wnRvCdrJehkIQvlmdCriHMrNeZr0MhSB8814uX5WXadTjMhC+BUF9H2C9BMUgvHN99pfmPMx6EbQhvFOdKiJJZLXR3k+N8E7NH8UNE99gvQzKEN6pZfyFqxLfY70MyhDeqZHruGFrLOtlUIbwzn1wKKNkPutF0IbwIgT2lnbCLz2QHT6uueORDRT+P145UlbUg/UiaJEd/tZ/DWh6g+HCP/OphURUGeWVevnhEz/LbvIU4IYLnx3GDQtGsl4GJfLDR5O4k2XTHc8Pabjwefyb52ePZb0MSmiEJx6DVv3pknCD4cKnLiKkdZW004JoF5XwHFNv4QbDhTctr8k6Npz1KmiRHX6OtZkNhgtPiE/Hu+fzbd/Rwngl8tF6HB8+uvFTa4zdrjw6M2uOX0He9mN9Wa9CLlrhk282fjp8hd3JEjoza84a7o59WI3eD9DAM3eSlfPDxq6slyETjfAeAU399TdueP673an3013LDu+Tfv5OQ/2FNG/hBsOGn7PEkyQUsV6FXLLDZ9nirZag2Pwtwg2GDW+aU1uxWfdnQpQdvq6D/YPvFeEGw4ZvFDljhn4PyJId/sw0+4ek08INhg8/suyl6eUJrFfhKtnh+13+Jjcz9+ylGOEGw4ev9SOkTTXrVbhK/r16c2Lq/NREx5OaGz18q0P8aNPrc3h4HO+yGk/ub70b/8Q3x/DhX9nas3fWFNarcBXCu25k5mb9vliH8LIFfFByIJn1IiRDeNn2TSCtd0xmvQqpEF6u8Gxu8NbdS5EIL1dv+/WrKhmvQjKEl8v7mC8hCZ+yXoZUCC/b8LLFHxUGsl6FVAgvn19cL/uxeNb4h1gvRTyEp2Zm0Xtb9urmGVyEp6VTEfdj/8ps1ssQC+Fpmcxf2iBIN4cWIzwtjy/mhh66uXeP8LT4HIklIaX9WS9DLISnJmytbfcQ1osQDeGp65lXlqf98ycgPG3hR7qQrrVhrJfhDMLTNiuJG559i/UynEF42pYM5oYhS1gvwxmEp+0J/rLE6x5nvQxnEJ66JYWLC9NZL8IphKcvPMH+BhuviW9r+HSYCK+UNhXzntn4IetVNAvhlbJkDDdkOZwaSCsQXin7+GMzXn6B9TKag/BKWT3o3qBJCK+UyBNPdH2zwMR6Gc1BeMWEvrt+iv29pB0f1uBxOQivNL+8/O1HtPdqLcIrbe0oQtpWe7JehhDCK62CH9Y/wnoZQgivtFL+h3275q5ciPBKS11uJkMOsl6FA4RXmumtYye2BLNehQOEV4vfp8ePb9LOhU0QXi3bxhEyZjPrVTRCeJWY7Oc+LtXMwzqEV4m5lB+LvViv4x6EV8vn/Qh5NJf1KhohvFpCvjh0qLA961U0Qnj1WO2X7/H/sKJiKuulILz6CsaRVutSWa8C4dXWgf/fYi5nvQyEV1v0b/kR4d2O55G2hAxj/zZ6hFfbkNqPtx5if5IshFedpXsk/yFsa1kxwzdaITwj3lWDSbsidgfhIjwjCe9zQ2eHa3epBuEZSX6DGwL2M9s/wjPyQIkHISlzme0f4Vl5sTLt82x2B9wjPDNB8V34D4/kluxh8NZKhGcsojqChFU+qPp+6YRv19bxNoQXZeYEbhj9S9X3Kzt8t4pekcfqb1d3FG5AeFHeG8ENg5apvl/Z4Y995L1vrY93xiHhBoQXJY5/KL8hUfX9yg5/oz258BAhbW4INyC8OAtLMorS1N+t7PC2t02bUgmZ9DvhBoQXKaB3G/7DlKMVpX3U26vs8OEnvt3/U0XlVYcTPCG8JE/t8CKhNeq944bCvfreL86dObaVw80IL4k9xJvj1d0fBeGjhbcgvCTb+ddqZzyn2v5ohU++2fjpwBV2JwvpzOwmkj82Ef/yUNX2p8Azd+GJdnt1c3kWbVh8PP/kE/wnEaqcModGeI8AjyZuxa96icz2O/e+e/ZsOKLC8Rmyw/ukn7/TUH8hzVu4AeFdsnoc9wDvS4f/m9TJDp9li7dagmLzHY4lQXiXVPBnxvuor+L7kR2+roP9g+8V4QaEd0kJ/w98ZifF9yM7/Jlp9g9Jp4UbEN4l0zZ4kRFFyp8QU3b4fpe/yc3MPXspRrgB4V3zelXZthDuY9irryl5qiz59+rNianzUxPNDrcjvCxDS58dW/SUcvPjCByNqgokpPVR5eZHeG3yPMyP+9sotgOE16gqL65+rXLzI7xGvZDfp+fO15SbH+G1asDKVfwliv1Wlh38hQLTI7zGff4i8fk0hf68CK9tQfnk3j09uhBe27ps4sdK+hMjvLZ5HA8g5LEs+hMjvMYNPrLst6X8MZhth3alOS/Ca13r2D78cS6TqlbnfE7xTLgIrw9hh7n6UxfSmxDh9WHMHG7wpXj8KsLrQ+xSboikeCcP4fXBUjaQtN0zhN6ECK8ToZkny/ijr8NXF62lcWAWwutL4NE4j5gvO8ifCOH15SX+EMdnKJwsC+H15d2R3PDoR/InQnh9SVzHDe9PlD8RwuvMhu0zNn7GH33dNylKzjwIrzfRST240Zyz6a0Dcs6VhfD69CZ/VFZOL9cnQHh9+iyCG56XcWQOwutTxgBumD/K9QkQXp+61Xb3HFnl4/oECK9TfXbZfhNCiGnBkbJ9rrzHDuH1LTXdg0QfduEa1Qivb/bLU6/tIf0PIry+2X/YM/pJ/4MIr28LpxMSXOXCsXgIr2/mjVUFtY9yn4zJ2pIk5TwaCK93fmH8mJIdFb52kYQ/hvDGUGnmHtpVN3W+wWYgvCGYKvhxr1X8n0B4YygNJcRfyplTEN4YHq15a0blMO6T7jNT2on5AwhvEIETJvMnSUvZP3riUYdTzzUB4Q3FfNxCSPsvRHwlwhvK3ctTV4j4SoQ3FO9aE/dbX8wJNBDeWN7/7cP9S/lDsMPGDmrxiTyEN5gnP1rGv1Y3vWT2soOtW/g6hDeksFLuxz1paQtfgfCGNGoeN1hsLXwFwhtS3zXcEPlZC1+B8IbkUZxsiSodyH0WmhDZ5FcgvDEFvFe47THu47ySxftXN/UFCG9oA3dww9LkJrYgvKG9w1/5tdfaJrYgvKFN5c+jMOJXTWxBeEOzHu1Boqr5c+ZEJYT8bAvCG1vXnLIDMYSYPtm3qmzm/RsQ3i1MW8ANe3redwvCuwV75kkzhLcoAuE1JIN/TP/6hPtuoRO+XaDjbQivIY8Uh5Ielf733SI7/MGOJOLLn26Xhwk3ILyWxBWf3PXg/TfIDn8rmuRu87WszBduQHhNoxH+T90ICfyHcAPCa5r88MPMB54mZMgl4QaE1zTZ4W3f37r2LUm4Nke4AeE1jcK9ekvnODIgweFmhNc0Wo/jw0cLb0F4TaMVPvnm/396yu7yATozgyKUe+buudeVmhkooBHeI6CpN+QjvKbJDu+Tfv5OQ/2FNG/hBoTXNNnhs2zxVktQbP4W4YaR5+/+W3/zR5pu/YvqdLc1PNu/blGd7sapnznv8By7RHV3L4zje6W5LxDz1k3x3h5Dc7bgPTRnI4W+NGf72auo8tHtQMiZafYPSafV2SHCu4p2+H6Xv8nNzD17qdmzMCC8izQenpgTU+enJppV2iHCu4p6eHV3iPCuQvj7ILyCWnqvrnSzZFyNw1FQLs3ZyAEZV4xwNOEVmrNR7iCCwzM7slgknLVTBLqLozubZ/P3m1xBd3EAAAAAAAAAYCAxp69tp/bUwaFoejOOPfdjRXd663vpLzf2BVP8dqP5g1cpzWa7devWQcopnDFfmh5Wmk5nrhGbG6KpzRh6fVTAkt9TW1/nuv5tizfQ+3Y9j9bT+5/3/bDo6I5UUzg34g+ExJ+nM9fc9T9GU5txXA0hXv9uS2t9UwoImVhD79udvbue2rdquWV/7pdmCudScwmx3qH1/PrFaGoz+ocQMvTPJlrr8/A0BW7OoPbtdj7XqZ7at9r52oE/fR5BOYUz8zO5v3ENAZRm48NTm9E09uIzFNc3seFyCK3pPMpHBddT+1bjvh0VveMo5RTO8H/Ngupp/8TTmNGaf6of1fVZF5yhNV1qNgmup7q41j+1o5vCmcSzhMT+N63Z+PCUZvT+ail/HWZa60uZQkjbBm9K0+Vcv/r3hqsDKc3Gv6HVcjuQbgpnzJfGtspLozXbxWhqM048E8XxpLW+cee7+i05RWtx1oiIXj9FeFOaLeHa4DYryimncKr/11e3UXvwyIenNOPKBl4wrfWZfv0/N0q6UPx2+V/1tGZ7+/L1gjDKKQAAAAAAAAAAAAAAAAAAAAAAAAAAyKlx9/1HYB2zdYDKEN5NnRoXXTv30l+GEzLrb397mws/9MyPxR3I1BqT5+lnWC8OlMOFv7nQd+VREv/3oREVdcT6w5i2Gw4TU83zb+xlvTZQEBf+upn0OEfWLCckro5M5XL73PQgPf76fTjrtYGCuPB/JCT6HMlJIaRDHVl0/bvvvrsWSkgZ3VPggsZw4c/Zw3+8jJCBdSRlOyEeUSYS//XFPqzXBgpqDB93dVBIyTUSdiUhMO0Y8f52yJQjar3dGBhoDE/eunhx+kVCnvrDP8s7k19lE48vp7JeHAAAAAAAAAAAAAAAAAAAAAAAAGjN/wH6zNa4jz6qpgAAAABJRU5ErkJggg==" alt="plot of chunk unnamed-chunk-18"/> </p>

</body>

</html>
